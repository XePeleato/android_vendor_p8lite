/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

// int __fastcall _cxa_finalize(_DWORD); weak
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// size_t strlen(const char *s);
// char *strcpy(char *dest, const char *src);
// int __fastcall strptime(_DWORD); weak
// time_t mktime(struct tm *tp);
// int open(const char *file, int oflag, ...);
// int __cdecl _errno(_DWORD, _DWORD, _DWORD); weak
// int socket(int domain, int type, int protocol);
// int fcntl(int fd, int cmd, ...);
// void *memset(void *s, int c, size_t n);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int close(int fd);
// int __fastcall _stack_chk_fail(_DWORD); weak
// __uid_t getuid(void);
// __pid_t getpid(void);
// int __cdecl gettid(_DWORD); weak
// ssize_t writev(int fd, const struct iovec *iovec, int count);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int access(const char *name, int type);
// int strcmp(const char *s1, const char *s2);
// int strncmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int __fastcall android_set_abort_message(_DWORD); weak
int __fastcall j___android_log_buf_write(signed int a1, int a2, const char *a3, const char *a4);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
int __fastcall j___android_log_write(int a1, const char *a2, const char *a3);
// void abort(void);
// int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
int __fastcall j___android_log_bwrite(int a1, int a2, int a3);
// int __fastcall _strlen_chk(_DWORD, _DWORD); weak
int __fastcall j___android_log_exception_write(const char *a1, int a2, const char *a3, const char *a4);
// int munmap(void *addr, size_t len);
// void free(void *ptr);
// void *calloc(size_t nmemb, size_t size);
// char *strerror(int errnum);
// __off_t lseek(int fd, __off_t offset, int whence);
// int fprintf(FILE *stream, const char *format, ...);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// unsigned __int32 strtoul(const char *nptr, char **endptr, int base);
// int fputs(const char *s, FILE *stream);
void __fastcall j_android_closeEventTagMap(unsigned __int64 *a1);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int __fastcall _system_property_serial(_DWORD); weak
// int __fastcall _system_property_read(_DWORD, _DWORD, _DWORD); weak
// int __fastcall _system_property_find(_DWORD); weak
// int __fastcall _system_property_area_serial(_DWORD); weak
// char *strdup(const char *s);
// int toupper(int c);
// int __fastcall _strncpy_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// size_t strcspn(const char *s, const char *reject);
// int tolower(int c);
// char *strsep(char **stringp, const char *delim);
int __fastcall j_android_log_addFilterRule(int a1, const char *a2);
int __fastcall j_android_lookupEventTag(int a1, int a2);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// void *malloc(size_t size);
// char *strcat(char *dest, const char *src);
// char *strncat(char *dest, const char *src, size_t n);
char *__fastcall j_android_log_formatLogLine(int a1, int a2, int a3, time_t *timer, int a5);
// ssize_t write(int fd, const void *buf, size_t n);
signed __int64 __fastcall j_systemTime(int a1, int a2, int a3);
int __fastcall j___android_janklog_buf_write(__int16 a1, int a2, int a3);
int __fastcall j___android_janklog_chgtm_buf_write(__int16 a1, int a2, __int64 s, char a4, int a5, char *sa);
// int __fastcall _open_2(_DWORD, _DWORD); weak
// int ioctl(int fd, unsigned __int32 request, ...);
unsigned int __fastcall j_hw_janklog_processLogBuffer(int a1, int a2);
// void exit(int status);
// int printf(const char *format, ...);
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// ssize_t read(int fd, void *buf, size_t nbytes);
signed int __fastcall j_android_log_processBinaryJlogBuffer(int a1, int a2, char *a3, size_t a4);
_BOOL4 __fastcall j_android_log_shouldPrintLine(int a1, const char *a2, unsigned int a3);
signed int __fastcall j_android_log_printLogLine(int a1, int a2, time_t *a3);
// void perror(const char *s);
// __uid_t geteuid(void);
// __gid_t getgid(void);
// __gid_t getegid(void);
// int getgroups(int size, __gid_t *list);
signed int __fastcall j_socket_make_sockaddr_un(const char *a1, int a2, void *a3, _DWORD *a4);
signed int __fastcall j_socket_local_client_connect(int a1, const char *a2, int a3);
signed int __fastcall j_socket_local_client(const char *a1, int a2, int a3);
// char *strrchr(const char *s, int c);
// int unlink(const char *name);
// __int32 atol(const char *nptr);
// void *memmove(void *dest, const void *src, size_t n);
// int __fastcall _memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// unsigned int alarm(unsigned int seconds);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
_DWORD *__fastcall j_android_logger_list_alloc(int a1, int a2, int a3);
_DWORD *__fastcall j_android_logger_open(_DWORD *result, unsigned int a2);
void __fastcall j_android_logger_list_free(int a1);
// void *dlopen(const char *file, int mode);
// char *dlerror(void);
// void *dlsym(void *handle, const char *name);
int __fastcall j___android_log_print(int a1, const char *a2, const char *a3);
// int __fastcall _aeabi_memcpy(_DWORD); weak
// int __fastcall _aeabi_memset(_DWORD, _DWORD, _DWORD); weak
// int dladdr(void); weak
// int __fastcall _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD); weak
int j___aeabi_ldiv0();
signed __int64 __fastcall j___gnu_ldivmod_helper(signed __int64 a1, signed __int64 a2, _QWORD *a3);
unsigned __int64 __fastcall j___gnu_uldivmod_helper(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3);
// int raise(int sig);
unsigned int __fastcall j___lshrdi3(unsigned int a1, unsigned int a2, int a3);
int sub_2B70();
int (*__fastcall sub_2B90(int (*result)(void)))(void);
const char *__fastcall log_time::strptime(log_time *this, const char *a2, const char *a3);
int __fastcall log_time::operator-=(int result, int a2, int a3);
int __fastcall log_time::operator+=(int result, int a2, int a3);
int __fastcall log_time::operator+=(int result, int a2, int a3);
int sub_2EA0();
_DWORD *__fastcall sub_2FBC(char a1, int *a2, int a3);
int __fastcall sub_3278(int a1, int *a2, int a3);
int _android_log_dev_available();
int __fastcall _android_log_buf_write(signed int a1, int a2, const char *a3, const char *a4);
int __fastcall _android_log_write(int a1, const char *a2, const char *a3);
int __fastcall _android_log_vprint(int a1, const char *a2, const char *a3, void *a4);
int _android_log_print(int a1, const char *a2, const char *a3, ...);
int _android_log_buf_print(signed int a1, int a2, const char *a3, const char *a4, ...);
int __fastcall _android_log_bwrite(int a1, int a2, int a3);
int __fastcall _android_log_btwrite(int a1, char a2, int a3, int a4);
int __fastcall _android_log_bswrite(int a1, const char *a2);
signed int __fastcall sub_36A0(int a1, int a2, signed int a3);
int __fastcall _android_log_error_write(int, char *s, int, int, int); // idb
int sub_3788(); // weak
ssize_t __fastcall _write_to_log_real_kernel(int a1, const struct iovec *a2, int a3);
int __fastcall sub_37C8(int a1, const struct iovec *a2, int a3);
int __fastcall _log_write_kernel_buf(int a1, int a2, const char *a3, const char *a4);
int _android_log_exception_write(const char *a1, int a2, const char *a3, const char *a4, ...);
int __fastcall _android_log_exception_msg_write(const char *a1, int a2, const char *a3);
int sub_3960(); // weak
signed int __fastcall sub_3968(int a1);
void __fastcall android_closeEventTagMap(unsigned __int64 *a1);
void *__fastcall android_openEventTagMap(const char *a1);
int __fastcall android_lookupEventTag(int a1, int a2);
int __fastcall sub_3D38(int *a1, int a2);
int __fastcall _android_log_is_loggable(signed int a1, const char *a2, signed int a3);
int __fastcall sub_3FB4(int a1);
int __fastcall sub_3FCC(_DWORD *a1, int *a2, char **a3, size_t *a4);
int __fastcall sub_41FC(char *a1, int a2, unsigned int a3);
_BOOL4 __fastcall android_log_shouldPrintLine(int a1, const char *a2, unsigned int a3);
_DWORD *android_log_format_new();
void __fastcall android_log_format_free(void *ptr);
signed int __fastcall android_log_setPrintFormat(int a1, int a2);
int __fastcall android_log_formatFromString(const char *a1);
int __fastcall android_log_addFilterRule(int a1, const char *a2);
signed int __fastcall android_log_addFilterString(int a1, const char *a2);
signed int __fastcall android_log_processLogBuffer(int a1, int a2);
signed int __fastcall android_log_processBinaryLogBuffer(int a1, _DWORD *a2, char *a3, int a4, size_t a5);
char *__fastcall android_log_formatLogLine(int a1, int a2, int a3, time_t *timer, int a5);
signed int __fastcall android_log_printLogLine(int a1, int a2, time_t *a3);
int sub_4CE8(); // weak
ssize_t __fastcall sub_4CF0(__int64 a1, int a2);
int __fastcall sub_4D20(int a1, int a2);
int __fastcall sub_4D90(__int64 iovec);
int __fastcall _android_janklog_buf_write(__int16 a1, int a2, int a3);
int __fastcall _android_janklog_chgtm_buf_write(__int16 a1, int a2, __int64 s, char a4, int a5, char *sa);
int _android_janklog_print(__int16 a1, int a2, const char *a3, ...);
int _android_janklog_chgtm_print(__int16 a1, int a2, __int64 format, char a4, int a5, char *formata, ...);
int __fastcall sub_4F70(int a1, unsigned __int32 a2, int a3);
unsigned int __fastcall hw_janklog_processLogBuffer(int a1, int a2);
signed int __fastcall android_log_processBinaryJlogBuffer(int a1, int a2, char *a3, size_t a4);
unsigned int __fastcall hwlog_is_janklog(const char *a1);
void __fastcall hwlog_print_janklog(int a1);
unsigned int __fastcall sub_5468(unsigned int a1);
int nullsub_1(); // weak
int __fastcall sub_5484(int a1, int a2, int a3, int a4);
int __fastcall sub_5548(const char *a1, int a2);
signed int __fastcall socket_make_sockaddr_un(const char *a1, int a2, void *a3, _DWORD *a4);
signed int __fastcall socket_local_client_connect(int a1, const char *a2, int a3);
signed int __fastcall socket_local_client(const char *a1, int a2, int a3);
signed int __fastcall sub_5680(int a1, int a2, char *a3, size_t a4);
char *__fastcall android_log_id_to_name(unsigned int a1);
signed int __fastcall android_name_to_log_id(const char *a1);
int __fastcall android_logger_get_id(int a1);
int __fastcall android_logger_clear(int a1);
signed int __fastcall android_logger_get_log_size(int a1);
int __fastcall android_logger_set_log_size(int a1, int a2);
signed int __fastcall android_logger_get_log_readable_size(int a1);
signed int android_logger_get_log_version();
signed int __fastcall android_logger_get_statistics(int *a1, char *a2, size_t a3);
signed int __fastcall android_logger_get_prune_list(int a1, char *a2, size_t a3);
signed int __fastcall android_logger_set_prune_list(int a1, int a2, size_t a3);
_DWORD *__fastcall android_logger_list_alloc(int a1, int a2, int a3);
_DWORD *__fastcall android_logger_list_alloc_time(int a1, __int64 a2, int a3);
_DWORD *__fastcall android_logger_open(_DWORD *result, unsigned int a2);
_DWORD *__fastcall android_logger_list_read(int a1, void *a2);
void __fastcall android_logger_list_free(int a1);
_DWORD *__fastcall android_logger_list_open(unsigned int a1, int a2, int a3, int a4);
int *sub_6064();
int __fastcall _android_logPower_buf_write(int a1, int a2, int a3);
int __fastcall _android_logPower_print(int a1, int a2, int a3, int a4);
signed __int64 __fastcall systemTime(int a1, int a2, int a3);
int __fastcall toMillisecondTimeoutDelay(__int64 a1, __int64 a2);
signed int __fastcall sub_6220(int a1, int a2, unsigned int a3, unsigned int a4);
signed int __fastcall sub_6564(int a1, int a2, unsigned int a3, int a4, int *a5);
signed int __fastcall sub_6608(int a1, int a2, unsigned int a3, int a4);
signed int __fastcall sub_672C(int a1, int a2, int a3);
void sub_6780();
void sub_6788();
signed int __fastcall sub_6824(int a1, int a2, char a3);
void __fastcall sub_6940(int a1, int a2, int a3);
int __fastcall sub_69C4(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_69DC(int _R0);
int __fastcall sub_69E4(int _R0);
int __fastcall sub_69EC(int _R0);
void sub_69F4();
void sub_6A38();
int __fastcall sub_6A4C(int a1);
signed int __fastcall sub_6A9C(int a1, int a2, _DWORD *a3);
signed int __fastcall sub_6ACC(int a1, int a2, int a3);
signed int __fastcall sub_6B10(int a1, int a2, _QWORD *a3);
signed int __fastcall sub_6B40(int a1, int a2, int a3, int a4);
int __fastcall sub_6B78(int a1);
signed int __fastcall sub_6B80(int a1, int a2);
signed int __fastcall sub_6BA0(int a1);
int __fastcall sub_6BB8(int a1);
int __fastcall sub_6BC8(int a1, int a2);
int __fastcall sub_6BEC(int a1, signed int a2);
int __fastcall sub_6C88(int result, signed int a2, int a3);
int __fastcall sub_6D20(int a1, int a2);
__int64 __fastcall sub_6D44(int a1, int a2);
int __fastcall sub_6DF4(int a1, int a2, int a3, int a4);
signed int __fastcall sub_6EC8(int a1);
int __fastcall sub_6F14(int a1, int a2);
void __fastcall sub_6F54(int a1);
int __fastcall sub_6F6C(int a1);
signed int __fastcall sub_6F74(int a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_6FD0(int a1, int a2);
const char *__fastcall sub_701C(int a1, signed int a2);
int __fastcall sub_7024(int result);
void __fastcall sub_702C(int a1, int a2, int a3, int a4);
int __fastcall sub_7060(int a1);
int sub_70B0(); // weak
int __fastcall sub_7240(int result, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, _DWORD *a8);
int sub_7918(); // weak
int __fastcall sub_792C(int _R0);
int __fastcall sub_7934(int _R0);
int __fastcall sub_793C(int _R0);
int __fastcall sub_7944(_DWORD *a1);
int __fastcall sub_7988(_DWORD *a1);
int _aeabi_ldiv0();
signed __int64 __fastcall _gnu_ldivmod_helper(signed __int64 a1, signed __int64 a2, _QWORD *a3);
unsigned __int64 __fastcall _gnu_uldivmod_helper(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3);
unsigned int __fastcall _lshrdi3(unsigned int a1, unsigned int a2, int a3);
int __fastcall j_j_j___android_log_buf_write(signed int a1, int a2, const char *a3, const char *a4);
int __fastcall j_j___android_log_buf_write(signed int a1, int a2, const char *a3, const char *a4);
void j_j_free(void *ptr);
void j_free(void *ptr);
int j_j_ioctl(int fd, unsigned __int32 request, ...);
int j_ioctl(int fd, unsigned __int32 request, ...);
void sub_7DB0();
void sub_7DB4();
int __fastcall sub_7DC0(_DWORD *a1);
int __fastcall sub_7DC4(_DWORD *a1);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_6218; // weak
_UNKNOWN loc_621A; // weak
_UNKNOWN loc_6734; // weak
_UNKNOWN unk_81F5; // weak
char aVdiwefs[8] = "VDIWEFS"; // weak
char aKJ[6] = "K(¦ÄÄ"; // weak
_DWORD dword_9058[6] = { 0, 1, 2, 3, 7, 0 }; // idb
char *off_AC88[6] = { "main", "radio", "events", "system", "crash", "kernel" }; // weak
void *off_ACB0 = (void *)0x6BC1; // weak
int GLOBAL_OFFSET_TABLE_ = 0; // weak
void *off_B000 = &off_B000; // weak
int dword_B004 = 4294967295; // weak
int dword_B008 = 4294967295; // weak
int dword_B00C = 4294967295; // weak
int (__fastcall *off_B010)(_DWORD, _DWORD, _DWORD) = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))0x3279; // weak
int dword_B018 = 4294967295; // weak
int (__fastcall *off_B020)(_DWORD, _DWORD, _DWORD) = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))0x37C9; // weak
_UNKNOWN unk_B024; // weak
char byte_B02C = '\0'; // weak
_UNKNOWN unk_B030; // weak
char byte_B038 = '\0'; // weak
int dword_B03C = 0; // weak
int dword_B040 = 4294967295; // weak
char byte_B044 = '\0'; // weak
int dword_B048 = 0; // weak
int dword_B04C = 4294967295; // weak
char byte_B050 = '\0'; // weak
int dword_B054 = 4294967295; // weak
int (__fastcall *off_B058)(_DWORD, _DWORD) = (int (__fastcall *)(_DWORD, _DWORD))0x4D21; // weak
int dword_B05C = 4294967295; // weak
int dword_B060; // weak
_UNKNOWN unk_B064; // weak
_UNKNOWN unk_B068; // weak
int dword_B06C; // weak
int dword_B070; // weak
int dword_B074; // weak
_UNKNOWN unk_B078; // weak
int dword_B07C; // weak
char byte_B080; // weak
int (__fastcall *dword_B084)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__fastcall *dword_B088)(_DWORD, _DWORD, _DWORD); // weak
int dword_B08C; // weak
_UNKNOWN unk_B090; // weak
// extern int _stack_chk_guard; idb
// extern struct _IO_FILE *stderr;


//----- (00002738) --------------------------------------------------------
int __fastcall j___android_log_buf_write(signed int a1, int a2, const char *a3, const char *a4)
{
  return _android_log_buf_write(a1, a2, a3, a4);
}

//----- (00002750) --------------------------------------------------------
int __fastcall j___android_log_write(int a1, const char *a2, const char *a3)
{
  return _android_log_write(a1, a2, a3);
}

//----- (00002780) --------------------------------------------------------
int __fastcall j___android_log_bwrite(int a1, int a2, int a3)
{
  return _android_log_bwrite(a1, a2, a3);
}

//----- (00002798) --------------------------------------------------------
int __fastcall j___android_log_exception_write(const char *a1, int a2, const char *a3, const char *a4)
{
  return _android_log_exception_write(a1, a2, a3, a4);
}

//----- (00002810) --------------------------------------------------------
void __fastcall j_android_closeEventTagMap(unsigned __int64 *a1)
{
  android_closeEventTagMap(a1);
}

//----- (000028A0) --------------------------------------------------------
int __fastcall j_android_log_addFilterRule(int a1, const char *a2)
{
  return android_log_addFilterRule(a1, a2);
}

//----- (000028AC) --------------------------------------------------------
int __fastcall j_android_lookupEventTag(int a1, int a2)
{
  return android_lookupEventTag(a1, a2);
}

//----- (000028E8) --------------------------------------------------------
char *__fastcall j_android_log_formatLogLine(int a1, int a2, int a3, time_t *timer, int a5)
{
  return android_log_formatLogLine(a1, a2, a3, timer, a5);
}

//----- (00002900) --------------------------------------------------------
signed __int64 __fastcall j_systemTime(int a1, int a2, int a3)
{
  return systemTime(a1, a2, a3);
}

//----- (00002918) --------------------------------------------------------
int __fastcall j___android_janklog_buf_write(__int16 a1, int a2, int a3)
{
  return _android_janklog_buf_write(a1, a2, a3);
}

//----- (00002924) --------------------------------------------------------
int __fastcall j___android_janklog_chgtm_buf_write(__int16 a1, int a2, __int64 s, char a4, int a5, char *sa)
{
  return _android_janklog_chgtm_buf_write(a1, a2, s, a4, a5, sa);
}

//----- (00002948) --------------------------------------------------------
unsigned int __fastcall j_hw_janklog_processLogBuffer(int a1, int a2)
{
  return hw_janklog_processLogBuffer(a1, a2);
}

//----- (00002984) --------------------------------------------------------
signed int __fastcall j_android_log_processBinaryJlogBuffer(int a1, int a2, char *a3, size_t a4)
{
  return android_log_processBinaryJlogBuffer(a1, a2, a3, a4);
}

//----- (00002990) --------------------------------------------------------
_BOOL4 __fastcall j_android_log_shouldPrintLine(int a1, const char *a2, unsigned int a3)
{
  return android_log_shouldPrintLine(a1, a2, a3);
}

//----- (0000299C) --------------------------------------------------------
signed int __fastcall j_android_log_printLogLine(int a1, int a2, time_t *a3)
{
  return android_log_printLogLine(a1, a2, a3);
}

//----- (000029E4) --------------------------------------------------------
signed int __fastcall j_socket_make_sockaddr_un(const char *a1, int a2, void *a3, _DWORD *a4)
{
  return socket_make_sockaddr_un(a1, a2, a3, a4);
}

//----- (000029F0) --------------------------------------------------------
signed int __fastcall j_socket_local_client_connect(int a1, const char *a2, int a3)
{
  return socket_local_client_connect(a1, a2, a3);
}

//----- (000029FC) --------------------------------------------------------
signed int __fastcall j_socket_local_client(const char *a1, int a2, int a3)
{
  return socket_local_client(a1, a2, a3);
}

//----- (00002A74) --------------------------------------------------------
_DWORD *__fastcall j_android_logger_list_alloc(int a1, int a2, int a3)
{
  return android_logger_list_alloc(a1, a2, a3);
}

//----- (00002A80) --------------------------------------------------------
_DWORD *__fastcall j_android_logger_open(_DWORD *result, unsigned int a2)
{
  return android_logger_open(result, a2);
}

//----- (00002A8C) --------------------------------------------------------
void __fastcall j_android_logger_list_free(int a1)
{
  android_logger_list_free(a1);
}

//----- (00002ABC) --------------------------------------------------------
int __fastcall j___android_log_print(int a1, const char *a2, const char *a3)
{
  return _android_log_print(a1, a2, a3);
}

//----- (00002B10) --------------------------------------------------------
int j___aeabi_ldiv0()
{
  return _aeabi_ldiv0();
}

//----- (00002B1C) --------------------------------------------------------
signed __int64 __fastcall j___gnu_ldivmod_helper(signed __int64 a1, signed __int64 a2, _QWORD *a3)
{
  return _gnu_ldivmod_helper(a1, a2, a3);
}

//----- (00002B28) --------------------------------------------------------
unsigned __int64 __fastcall j___gnu_uldivmod_helper(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  return _gnu_uldivmod_helper(a1, a2, a3);
}

//----- (00002B64) --------------------------------------------------------
unsigned int __fastcall j___lshrdi3(unsigned int a1, unsigned int a2, int a3)
{
  return _lshrdi3(a1, a2, a3);
}

//----- (00002B70) --------------------------------------------------------
int sub_2B70()
{
  return _cxa_finalize(&off_B000);
}
// 25E8: using guessed type int __fastcall _cxa_finalize(_DWORD);
// B000: using guessed type void *off_B000;

//----- (00002B90) --------------------------------------------------------
int (*__fastcall sub_2B90(int (*result)(void)))(void)
{
  if ( result )
    result = (int (*)(void))result();
  return result;
}

//----- (00002C50) --------------------------------------------------------
const char *__fastcall log_time::strptime(log_time *this, const char *a2, const char *a3)
{
  log_time *v3; // r5@1
  const char *v4; // r4@1
  const char *v5; // r6@1
  int v6; // r0@1
  int v7; // r2@1
  struct tm *v8; // r10@1
  int *v9; // r8@1
  int *v10; // r1@1
  int v11; // r11@6
  int v12; // r6@6
  _BYTE *v13; // r12@7
  const char *v14; // r0@10
  int v15; // r8@11
  int v16; // r2@14
  unsigned int v17; // r0@19
  int v18; // r12@21
  int v19; // r6@21
  unsigned int v20; // r2@22
  int v21; // r0@30
  int v23; // [sp+0h] [bp+0h]@1
  struct tm *tp; // [sp+4h] [bp+4h]@1
  int v25; // [sp+8h] [bp+8h]@1
  int v26; // [sp+Ch] [bp+Ch]@30
  int v27; // [sp+10h] [bp+10h]@30
  int v28; // [sp+14h] [bp+14h]@1
  int v29; // [sp+18h] [bp+18h]@1

  v3 = this;
  v4 = a2;
  v5 = a3;
  tp = (struct tm *)&v28;
  clock_gettime(0, (struct timespec *)&v28);
  v6 = v28;
  v7 = v29;
  *(_DWORD *)v3 = v28;
  *((_DWORD *)v3 + 1) = v7;
  v25 = v6;
  v8 = localtime_r((const time_t *)&v25, (struct tm *)&v28);
  strlen(v5);
  v9 = &v23;
  strcpy((char *)&v23, v5);
  v10 = &v23;
  while ( *(_BYTE *)v9 )
  {
    if ( *(_BYTE *)v9 != 37 )
      goto LABEL_27;
    v11 = (int)v9 + 1;
    v12 = 0;
    if ( *((_BYTE *)v9 + 1) == 115 )
    {
      *(_BYTE *)v9 = 0;
      if ( *(_BYTE *)v10 )
      {
        v4 = (const char *)strptime(v4);
        if ( !v4 )
          goto LABEL_30;
      }
      v14 = v4;
      *(_BYTE *)v3 = 0;
      *((_BYTE *)v3 + 1) = 0;
      *((_BYTE *)v3 + 2) = 0;
      *((_BYTE *)v3 + 3) = 0;
      while ( 1 )
      {
        v4 = v14++;
        v15 = *v4;
        if ( (unsigned int)(v15 - 48) > 9 )
          break;
        *(_DWORD *)v3 = v15 + 10 * *(_DWORD *)v3 - 48;
      }
      v25 = *(_DWORD *)v3;
      v8 = localtime_r((const time_t *)&v25, tp);
      goto LABEL_26;
    }
    v13 = (char *)v9 + 1;
    while ( 1 )
    {
      v16 = *v13;
      v11 = (int)v13++;
      if ( (unsigned int)(v16 - 48) > 9 )
        break;
      v12 = v16 + 10 * v12 - 48;
    }
    if ( v16 == 113 )
    {
      *(_BYTE *)v9 = 0;
      if ( *(_BYTE *)v10 )
      {
        v4 = (const char *)strptime(v4);
        if ( !v4 )
          goto LABEL_30;
      }
      v17 = 1000000000;
      if ( !v12 )
        v12 = 0x7FFFFFFF;
      v18 = (int)(v4 + 9);
      v19 = (int)&v4[v12];
      *((_BYTE *)v3 + 4) = 0;
      *((_BYTE *)v3 + 5) = 0;
      *((_BYTE *)v3 + 6) = 0;
      *((_BYTE *)v3 + 7) = 0;
      while ( 1 )
      {
        v20 = *v4 - 48;
        if ( v20 > 9 || v4 == (const char *)v19 || v4 == (const char *)v18 )
          break;
        ++v4;
        v17 /= 0xAu;
        *((_DWORD *)v3 + 1) += v17 * v20;
      }
LABEL_26:
      v10 = (int *)(v11 + 1);
      v9 = (int *)v11;
    }
LABEL_27:
    v9 = (int *)((char *)v9 + 1);
  }
  if ( v10 != v9 )
    v4 = (const char *)strptime(v4);
  if ( v4 )
  {
    *(_DWORD *)v3 = mktime(v8);
    return v4;
  }
LABEL_30:
  clock_gettime(0, (struct timespec *)&v26);
  v4 = 0;
  v21 = v27;
  *(_DWORD *)v3 = v26;
  *((_DWORD *)v3 + 1) = v21;
  return v4;
}
// 263C: using guessed type int __fastcall strptime(_DWORD);

//----- (00002DD4) --------------------------------------------------------
int __fastcall log_time::operator-=(int result, int a2, int a3)
{
  int v3; // r5@5
  int v4; // r1@5
  unsigned int v5; // r3@6
  unsigned int v6; // r5@6

  if ( *(_DWORD *)a2 > *(_DWORD *)a3 || *(_DWORD *)a2 == *(_DWORD *)a3 && *(_DWORD *)(a2 + 4) > *(_DWORD *)(a3 + 4) )
  {
    v5 = *(_DWORD *)(a2 + 4);
    v6 = *(_DWORD *)(a3 + 4);
    if ( v5 >= v6 )
    {
      *(_DWORD *)(a2 + 4) = v5 - v6;
    }
    else
    {
      --*(_DWORD *)a2;
      *(_DWORD *)(a2 + 4) = v5 + 1000000000 - *(_DWORD *)(a3 + 4);
    }
    *(_DWORD *)a2 -= *(_DWORD *)a3;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 1) = 0;
    *(_BYTE *)(a2 + 2) = 0;
    *(_BYTE *)(a2 + 3) = 0;
    *(_BYTE *)(a2 + 4) = 0;
    *(_BYTE *)(a2 + 5) = 0;
    *(_BYTE *)(a2 + 6) = 0;
    *(_BYTE *)(a2 + 7) = 0;
  }
  v3 = *(_DWORD *)a2;
  v4 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = v3;
  *(_DWORD *)(result + 4) = v4;
  return result;
}

//----- (00002E30) --------------------------------------------------------
int __fastcall log_time::operator+=(int result, int a2, int a3)
{
  unsigned int v3; // r3@1
  signed int v4; // r4@1
  int v5; // r4@5
  int v6; // r3@5
  int v7; // r3@6
  int v8; // r1@6

  v3 = *(_DWORD *)(a3 + 4) + *(_DWORD *)(a2 + 4);
  v4 = 999999999;
  if ( v3 <= 0x3B9AC9FF )
    *(_DWORD *)(a2 + 4) = v3;
  else
    v4 = -1000000000;
  if ( v3 > 0x3B9AC9FF )
  {
    v5 = v4 + v3;
    v6 = *(_DWORD *)a2;
    *(_DWORD *)(a2 + 4) = v5;
    *(_DWORD *)a2 = v6 + 1;
  }
  *(_DWORD *)a2 += *(_DWORD *)a3;
  v7 = *(_DWORD *)a2;
  v8 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = v7;
  *(_DWORD *)(result + 4) = v8;
  return result;
}

//----- (00002E68) --------------------------------------------------------
int __fastcall log_time::operator+=(int result, int a2, int a3)
{
  unsigned int v3; // r3@1
  signed int v4; // r4@1
  int v5; // r4@5
  int v6; // r3@5
  int v7; // r4@6
  int v8; // r1@6

  v3 = *(_DWORD *)(a2 + 4) + *(_DWORD *)(a3 + 4);
  v4 = 999999999;
  if ( v3 <= 0x3B9AC9FF )
    *(_DWORD *)(a2 + 4) = v3;
  else
    v4 = -1000000000;
  if ( v3 > 0x3B9AC9FF )
  {
    v5 = v4 + v3;
    v6 = *(_DWORD *)a2;
    *(_DWORD *)(a2 + 4) = v5;
    *(_DWORD *)a2 = v6 + 1;
  }
  *(_DWORD *)a2 += *(_DWORD *)a3;
  v7 = *(_DWORD *)a2;
  v8 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = v7;
  *(_DWORD *)(result + 4) = v8;
  return result;
}

//----- (00002EA0) --------------------------------------------------------
int sub_2EA0()
{
  int v0; // r1@2
  int v1; // r2@2
  int v2; // r4@2
  _DWORD *v3; // r0@6
  int v4; // r2@6
  int v5; // r1@6
  int v6; // r5@6
  int v7; // r4@10
  _DWORD *v8; // r0@11
  int v9; // r1@11
  int v10; // r2@11
  int result; // r0@22
  __int16 s; // [sp+4h] [bp-84h]@14
  char dest; // [sp+6h] [bp-82h]@14
  int v14; // [sp+74h] [bp-14h]@1

  v14 = _stack_chk_guard;
  if ( dword_B00C < 0 )
  {
    do
      v2 = open("/dev/pmsg0", 1);
    while ( v2 == -1 && *(_DWORD *)_errno(0, v0, v1) == 4 );
    dword_B00C = v2;
  }
  if ( dword_B008 < 0 )
  {
    while ( 1 )
    {
      v3 = (_DWORD *)socket(1, 524290, 0);
      v5 = (int)v3 + 1;
      v6 = (int)v3;
      if ( v3 != (_DWORD *)-1 )
        break;
      v3 = (_DWORD *)_errno(-1, v5, v4);
      if ( *v3 != 4 )
        goto LABEL_10;
    }
    if ( (signed int)v3 < 0 )
    {
LABEL_10:
      v7 = -*(_DWORD *)_errno(v3, v5, v4);
      goto LABEL_22;
    }
    while ( 1 )
    {
      v8 = (_DWORD *)fcntl(v6, 4, 2048);
      v10 = (int)v8 + 1;
      if ( v8 != (_DWORD *)-1 )
        break;
      v8 = (_DWORD *)_errno(-1, v9, v10);
      v10 = *v8;
      if ( *v8 != 4 )
        goto LABEL_19;
    }
    if ( (signed int)v8 < 0 )
      goto LABEL_19;
    memset(&s, 0, 0x6Eu);
    s = 1;
    strcpy(&dest, "/dev/socket/logdw");
    while ( 1 )
    {
      v8 = (_DWORD *)connect(v6, (const struct sockaddr *)&s, 0x6Eu);
      if ( v8 != (_DWORD *)-1 )
        break;
      v8 = (_DWORD *)_errno(-1, v9, v10);
      if ( *v8 != 4 )
        goto LABEL_19;
    }
    if ( (signed int)v8 < 0 )
    {
LABEL_19:
      v7 = -*(_DWORD *)_errno(v8, v9, v10);
      close(v6);
      goto LABEL_22;
    }
    dword_B008 = v6;
  }
  v7 = 0;
LABEL_22:
  result = v7;
  if ( v14 != _stack_chk_guard )
    _stack_chk_fail(v7);
  return result;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// B008: using guessed type int dword_B008;
// B00C: using guessed type int dword_B00C;

//----- (00002FBC) --------------------------------------------------------
_DWORD *__fastcall sub_2FBC(char a1, int *a2, int a3)
{
  unsigned int v3; // r6@1
  char v4; // r11@1
  int *v5; // r5@1
  unsigned int v6; // r9@7
  ssize_t v7; // r0@10
  int v8; // r2@10
  unsigned int v9; // r8@14
  int *v10; // r1@15
  char *v11; // r0@15
  unsigned int v12; // r3@15
  unsigned int i; // r5@15
  int v14; // r2@17
  int v15; // r2@17
  int v16; // r3@18
  int v17; // r1@25
  int v18; // r2@25
  int v19; // r5@29
  int v20; // r1@30
  int v21; // r2@30
  _DWORD *v22; // r0@34
  _DWORD *v23; // r9@34
  int v24; // r4@35
  unsigned int v25; // r5@44
  _DWORD *result; // r0@24
  char v27; // [sp+0h] [bp+0h]@6
  __int16 v28; // [sp+1h] [bp+1h]@22
  char v29[5]; // [sp+3h] [bp+3h]@6
  char *v30; // [sp+8h] [bp+8h]@6
  int v31; // [sp+Ch] [bp+Ch]@6
  int *v32; // [sp+10h] [bp+10h]@9
  char v33[5]; // [sp+14h] [bp+14h]@9
  char v34; // [sp+1Ch] [bp+1Ch]@6
  __int16 v35; // [sp+1Dh] [bp+1Dh]@6
  char *v36; // [sp+1Fh] [bp+1Fh]@6
  int v37; // [sp+23h] [bp+23h]@6

  v3 = a3 + 2;
  v4 = a1;
  v5 = a2;
  if ( !a3 )
    return (_DWORD *)-22;
  if ( !dword_B06C )
    dword_B06C = getuid();
  if ( dword_B004 == -1 )
    dword_B004 = getpid();
  clock_gettime(0, (struct timespec *)&v30);
  v35 = gettid((unsigned __int16)dword_B06C);
  *(_DWORD *)&v27 = &v27;
  *(_DWORD *)&v29[1] = 7;
  v36 = v30;
  v37 = v31;
  v30 = &v34;
  v31 = 11;
  if ( dword_B008 > 0 )
  {
    do
      v6 = __ldrex((unsigned int *)&unk_B064);
    while ( __strex(0, (unsigned int *)&unk_B064) );
    if ( v6 )
    {
      *(_DWORD *)&v33[1] = v6;
      v34 = 2;
      v32 = (int *)&v32;
      *(_DWORD *)v33 = 9;
      while ( 1 )
      {
        v7 = writev(dword_B008, (const struct iovec *)&v30, 2);
        if ( v7 != -1 )
          break;
        if ( *(_DWORD *)_errno(-1, 0, v8) != 4 )
          goto LABEL_14;
      }
      if ( v7 == 20 )
        goto LABEL_15;
      do
LABEL_14:
        v9 = __ldrex((unsigned int *)&unk_B064);
      while ( __strex(v9 + v6, (unsigned int *)&unk_B064) );
    }
  }
LABEL_15:
  v10 = v5;
  v11 = &v27;
  v34 = v4;
  v12 = 0;
  for ( i = 2; i < v3; ++i )
  {
    v14 = *v10;
    v11 += 8;
    v10 += 2;
    *((_DWORD *)v11 + 2) = v14;
    v15 = *(v10 - 1);
    v12 += v15;
    *((_DWORD *)v11 + 3) = v15;
    if ( v12 > 0xFEC )
    {
      v16 = v15 + 4076 - v12;
      *((_DWORD *)&v27 + 2 * i + 1) = v16;
      if ( v16 )
        ++i;
      LOWORD(v12) = 4076;
      break;
    }
  }
  v28 += v12;
  if ( dword_B00C >= 0 )
  {
    while ( writev(dword_B00C, (const struct iovec *)&v27, i) == -1 && *(_DWORD *)_errno(0, v17, v18) == 4 )
      ;
  }
  if ( dword_B06C == 1036 )
    return 0;
  if ( dword_B008 < 0 )
    return (_DWORD *)-9;
  v19 = i - 1;
  while ( 1 )
  {
    result = (_DWORD *)writev(dword_B008, (const struct iovec *)&v30, v19);
    v21 = (int)result + 1;
    if ( result != (_DWORD *)-1 )
      break;
    result = (_DWORD *)_errno(-1, v20, v21);
    v20 = *result;
    if ( *result != 4 )
      goto LABEL_34;
  }
  if ( (signed int)result >= 0 )
  {
LABEL_49:
    if ( (signed int)result > 11 )
      goto LABEL_42;
  }
  else
  {
LABEL_34:
    v22 = (_DWORD *)_errno(result, v20, v21);
    v23 = v22;
    result = (_DWORD *)-*v22;
    if ( result == (_DWORD *)-107 )
    {
      pthread_mutex_lock((pthread_mutex_t *)&unk_B068);
      close(dword_B008);
      dword_B008 = -1;
      v24 = sub_2EA0();
      pthread_mutex_unlock((pthread_mutex_t *)&unk_B068);
      if ( v24 < 0 )
        return (_DWORD *)v24;
      while ( 1 )
      {
        result = (_DWORD *)writev(dword_B008, (const struct iovec *)&v30, v19);
        if ( result != (_DWORD *)-1 )
          break;
        if ( *v23 != 4 )
          goto LABEL_40;
      }
      if ( (signed int)result >= 0 )
        goto LABEL_49;
LABEL_40:
      result = (_DWORD *)-*v23;
    }
    if ( (signed int)result > 11 )
    {
LABEL_42:
      result = (_DWORD *)((char *)result - 11);
      return result;
    }
    if ( result == (_DWORD *)-11 )
    {
      do
        v25 = __ldrex((unsigned int *)&unk_B064);
      while ( __strex(v25 + 1, (unsigned int *)&unk_B064) );
    }
  }
  return result;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 26CC: using guessed type int __cdecl gettid(_DWORD);
// B000: using guessed type void *off_B000;
// B004: using guessed type int dword_B004;
// B008: using guessed type int dword_B008;
// B00C: using guessed type int dword_B00C;
// B06C: using guessed type int dword_B06C;

//----- (00003278) --------------------------------------------------------
int __fastcall sub_3278(int a1, int *a2, int a3)
{
  int v3; // r6@1
  int v4; // r4@1
  int *v5; // r5@1
  int v6; // r9@2

  v3 = a1;
  v4 = a3;
  v5 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_B068);
  if ( (char *)off_B010 != (char *)sub_3278 )
    goto LABEL_6;
  v6 = sub_2EA0();
  if ( v6 >= 0 )
  {
    off_B010 = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))sub_2FBC;
LABEL_6:
    pthread_mutex_unlock((pthread_mutex_t *)&unk_B068);
    return off_B010(v3, v5, v4);
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_B068);
  if ( dword_B00C >= 0 )
    sub_2FBC(v3, v5, v4);
  return v6;
}
// B00C: using guessed type int dword_B00C;
// B010: using guessed type int (__fastcall *off_B010)(_DWORD, _DWORD, _DWORD);

//----- (00003308) --------------------------------------------------------
int _android_log_dev_available()
{
  signed int v0; // r0@3

  if ( !dword_B060 )
  {
    if ( access("/dev/socket/logdw", 2) )
      v0 = 1;
    else
      v0 = 2;
    dword_B060 = v0;
  }
  return dword_B060 - 2 + ((unsigned int)(dword_B060 - 2) <= 0) - (dword_B060 - 2);
}
// B060: using guessed type int dword_B060;

//----- (00003344) --------------------------------------------------------
int __fastcall _android_log_buf_write(signed int a1, int a2, const char *a3, const char *a4)
{
  const char *v4; // r7@1
  signed int v5; // r5@1
  char *v6; // r4@1
  char *v7; // r3@15
  size_t v8; // r0@18
  int result; // r0@18
  int v10; // [sp+4h] [bp-5Ch]@1
  int *v11; // [sp+Ch] [bp-54h]@18
  int v12; // [sp+10h] [bp-50h]@18
  char *v13; // [sp+14h] [bp-4Ch]@18
  size_t v14; // [sp+18h] [bp-48h]@18
  const char *v15; // [sp+1Ch] [bp-44h]@18
  size_t v16; // [sp+20h] [bp-40h]@18
  char s; // [sp+24h] [bp-3Ch]@15
  int v18; // [sp+44h] [bp-1Ch]@1

  v4 = a4;
  v5 = a1;
  v10 = a2;
  v6 = (char *)a3;
  v18 = _stack_chk_guard;
  if ( a3 )
  {
    if ( a1 == 1 )
      goto LABEL_16;
    if ( !strcmp(a3, "HTC_RIL") )
      goto LABEL_15;
  }
  else
  {
    if ( a1 == 1 )
    {
      v6 = (char *)&unk_81F5;
      goto LABEL_16;
    }
    v6 = (char *)&unk_81F5;
  }
  if ( !strncmp(v6, "RIL", 3u)
    || !strncmp(v6, "IMS", 3u)
    || !strcmp(v6, "AT")
    || !strcmp(v6, "GSM")
    || !strcmp(v6, "STK")
    || !strcmp(v6, "CDMA")
    || !strcmp(v6, "PHONE")
    || !strcmp(v6, "SMS") )
  {
LABEL_15:
    v7 = v6;
    v6 = &s;
    v5 = 1;
    snprintf(&s, 0x20u, "use-Rlog/RLOG-%s", v7);
  }
LABEL_16:
  if ( v10 == 7 )
    android_set_abort_message(v4);
  v13 = v6;
  v11 = &v10;
  v12 = 1;
  v8 = strlen(v6);
  v15 = v4;
  v14 = v8 + 1;
  v16 = strlen(v4) + 1;
  result = off_B010(v5, &v11, 3);
  if ( v18 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 272C: using guessed type int __fastcall android_set_abort_message(_DWORD);
// B010: using guessed type int (__fastcall *off_B010)(_DWORD, _DWORD, _DWORD);

//----- (0000347C) --------------------------------------------------------
int __fastcall _android_log_write(int a1, const char *a2, const char *a3)
{
  return j_j_j___android_log_buf_write(0, a1, a2, a3);
}

//----- (00003494) --------------------------------------------------------
int __fastcall _android_log_vprint(int a1, const char *a2, const char *a3, void *a4)
{
  const char *v4; // r6@1
  int v5; // r7@1
  int result; // r0@1
  char s; // [sp+4h] [bp-41Ch]@1
  int v8; // [sp+404h] [bp-1Ch]@1

  v4 = a2;
  v5 = a1;
  v8 = _stack_chk_guard;
  vsnprintf(&s, 0x400u, a3, a4);
  result = j___android_log_write(v5, v4, &s);
  if ( v8 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (000034D8) --------------------------------------------------------
int _android_log_print(int a1, const char *a2, const char *a3, ...)
{
  const char *v3; // r6@1
  int v4; // r7@1
  int result; // r0@1
  char s; // [sp+4h] [bp-424h]@1
  int v7; // [sp+404h] [bp-24h]@1
  va_list va; // [sp+424h] [bp-4h]@1

  va_start(va, a3);
  v3 = a2;
  v4 = a1;
  v7 = _stack_chk_guard;
  vsnprintf(&s, 0x400u, a3, va);
  result = j___android_log_write(v4, v3, &s);
  if ( v7 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00003530) --------------------------------------------------------
int _android_log_buf_print(signed int a1, int a2, const char *a3, const char *a4, ...)
{
  int v4; // r7@1
  const char *v5; // r6@1
  signed int v6; // r8@1
  int result; // r0@1
  char s; // [sp+4h] [bp-424h]@1
  int v9; // [sp+404h] [bp-24h]@1
  va_list va; // [sp+428h] [bp+0h]@1

  va_start(va, a4);
  v4 = a2;
  v5 = a3;
  v6 = a1;
  v9 = _stack_chk_guard;
  vsnprintf(&s, 0x400u, a4, va);
  result = j___android_log_buf_write(v6, v4, v5, &s);
  if ( v9 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (000035F4) --------------------------------------------------------
int __fastcall _android_log_bwrite(int a1, int a2, int a3)
{
  int v4; // [sp+4h] [bp-1Ch]@1
  int *v5; // [sp+8h] [bp-18h]@1
  int v6; // [sp+Ch] [bp-14h]@1
  int v7; // [sp+10h] [bp-10h]@1
  int v8; // [sp+14h] [bp-Ch]@1

  v7 = a2;
  v4 = a1;
  v5 = &v4;
  v6 = 4;
  v8 = a3;
  return off_B010(2, &v5, 2);
}
// B010: using guessed type int (__fastcall *off_B010)(_DWORD, _DWORD, _DWORD);

//----- (00003620) --------------------------------------------------------
int __fastcall _android_log_btwrite(int a1, char a2, int a3, int a4)
{
  char v5; // [sp+3h] [bp-25h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int *v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  char *v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1

  v12 = a4;
  v6 = a1;
  v5 = a2;
  v8 = 4;
  v7 = &v6;
  v10 = 1;
  v9 = &v5;
  v11 = a3;
  return off_B010(2, &v7, 3);
}
// B010: using guessed type int (__fastcall *off_B010)(_DWORD, _DWORD, _DWORD);

//----- (00003658) --------------------------------------------------------
int __fastcall _android_log_bswrite(int a1, const char *a2)
{
  int v2; // r5@1
  size_t v3; // r0@1
  int v5; // [sp+4h] [bp-3Ch]@1
  char v6; // [sp+Bh] [bp-35h]@1
  size_t v7; // [sp+Ch] [bp-34h]@1
  int *v8; // [sp+10h] [bp-30h]@1
  int v9; // [sp+14h] [bp-2Ch]@1
  char *v10; // [sp+18h] [bp-28h]@1
  int v11; // [sp+1Ch] [bp-24h]@1
  int *v12; // [sp+20h] [bp-20h]@1
  int v13; // [sp+24h] [bp-1Ch]@1
  int v14; // [sp+28h] [bp-18h]@1
  size_t v15; // [sp+2Ch] [bp-14h]@1

  v2 = (int)a2;
  v5 = a1;
  v6 = 2;
  v3 = strlen(a2);
  v7 = v3;
  v15 = v3;
  v8 = &v5;
  v10 = &v6;
  v14 = v2;
  v12 = (int *)&v7;
  v9 = 4;
  v11 = 1;
  v13 = 4;
  return off_B010(2, &v8, 4);
}
// B010: using guessed type int (__fastcall *off_B010)(_DWORD, _DWORD, _DWORD);

//----- (000036A0) --------------------------------------------------------
signed int __fastcall sub_36A0(int a1, int a2, signed int a3)
{
  int v3; // r1@1
  signed int result; // r0@1

  *(_BYTE *)(a1 + a2) = a3;
  v3 = a2 + a1;
  result = a3 >> 16;
  *(_BYTE *)(v3 + 1) = BYTE1(a3);
  *(_BYTE *)(v3 + 2) = a3 >> 16;
  *(_BYTE *)(v3 + 3) = BYTE3(a3);
  return result;
}

//----- (000036B4) --------------------------------------------------------
int __fastcall _android_log_error_write(int a1, char *s, int a3, int a4, int a5)
{
  const void *v5; // r10@1
  int v6; // r9@1
  int v7; // r11@1
  char *v8; // r8@1
  unsigned int v9; // r0@4
  unsigned int v10; // r4@6
  int v11; // r6@6
  char *v12; // r8@8
  int v13; // r1@8
  int v14; // r4@8
  char *v15; // r0@9
  int result; // r0@10
  char v17[7]; // [sp+Ch] [bp-22Ch]@8
  char v18; // [sp+Dh] [bp-22Bh]@8
  char v19; // [sp+Eh] [bp-22Ah]@8
  char v20; // [sp+13h] [bp-225h]@8
  int v21; // [sp+20Ch] [bp-2Ch]@1

  v5 = (const void *)a4;
  v6 = a1;
  v7 = a3;
  v8 = s;
  v21 = _stack_chk_guard;
  if ( s && (a4 || !a5) )
  {
    v9 = strlen(s);
    if ( v9 >= 0x20 )
      v9 = 32;
    v10 = v9;
    v11 = 495 - v9;
    if ( 495 - v9 >= a5 )
      v11 = a5;
    v19 = 2;
    v17[0] = 3;
    v18 = 3;
    sub_36A0((int)v17, 3, v9);
    _memcpy_chk(&v20, v8, v10, 505);
    v12 = &v17[v10];
    v17[v10 + 7] = 0;
    sub_36A0((int)v17, v10 + 8, v7);
    v13 = v10 + 13;
    v14 = v10 + 17;
    v12[12] = 2;
    sub_36A0((int)v17, v13, v11);
    if ( v11 )
    {
      v15 = &v17[v14];
      v14 += v11;
      memcpy(v15, v5, v11);
    }
    result = j___android_log_bwrite(v6, (int)v17, v14);
  }
  else
  {
    result = -22;
  }
  if ( v21 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 2768: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 36B4: using guessed type char var_22C[7];

//----- (00003790) --------------------------------------------------------
ssize_t __fastcall _write_to_log_real_kernel(int a1, const struct iovec *a2, int a3)
{
  const struct iovec *v3; // r5@1
  int v4; // r6@1
  int v5; // r4@2
  ssize_t result; // r0@3
  int v7; // r1@3
  int v8; // r2@3

  v3 = a2;
  v4 = a3;
  if ( a1 || (v5 = dword_B018, dword_B018 < 0) )
  {
    result = -9;
  }
  else
  {
    do
    {
      result = writev(v5, v3, v4);
      if ( result >= 0 )
        break;
      result = -*(_DWORD *)_errno(result, v7, v8);
    }
    while ( result == -4 );
  }
  return result;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// B018: using guessed type int dword_B018;

//----- (000037C8) --------------------------------------------------------
int __fastcall sub_37C8(int a1, const struct iovec *a2, int a3)
{
  const struct iovec *v3; // r6@1
  int v4; // r7@1
  int v5; // r5@1
  char *v6; // r0@1
  int v7; // r0@1
  ssize_t (__fastcall *v8)(int, const struct iovec *, int); // r3@2
  int result; // r0@4
  char dest; // [sp+4h] [bp-5Ch]@1
  int v11; // [sp+44h] [bp-1Ch]@1

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v11 = _stack_chk_guard;
  v6 = strcpy(&dest, "/dev/hwlog_exception");
  v7 = open(v6, 524289);
  if ( v7 < 0 )
  {
    v8 = (ssize_t (__fastcall *)(int, const struct iovec *, int))sub_3788;
    dword_B018 = -1;
  }
  else
  {
    v8 = _write_to_log_real_kernel;
    dword_B018 = v7;
  }
  off_B020 = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))v8;
  result = v8(v4, v3, v5);
  if ( v11 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 3788: using guessed type int sub_3788();
// B018: using guessed type int dword_B018;
// B020: using guessed type int (__fastcall *off_B020)(_DWORD, _DWORD, _DWORD);

//----- (00003854) --------------------------------------------------------
int __fastcall _log_write_kernel_buf(int a1, int a2, const char *a3, const char *a4)
{
  int v4; // r5@1
  const char *v5; // r4@1
  size_t v6; // r0@3
  int v8; // [sp+4h] [bp-2Ch]@1
  int *v9; // [sp+8h] [bp-28h]@3
  int v10; // [sp+Ch] [bp-24h]@3
  const char *v11; // [sp+10h] [bp-20h]@3
  size_t v12; // [sp+14h] [bp-1Ch]@3
  const char *v13; // [sp+18h] [bp-18h]@3
  size_t v14; // [sp+1Ch] [bp-14h]@3

  v4 = a1;
  v5 = a4;
  v8 = a2;
  if ( !a3 )
    a3 = (const char *)&unk_81F5;
  v11 = a3;
  v10 = 1;
  v9 = &v8;
  v6 = strlen(a3);
  v13 = v5;
  v12 = v6 + 1;
  v14 = strlen(v5) + 1;
  return off_B020(v4, &v9, 3);
}
// B020: invalid function type has been ignored
// B020: using guessed type int (__fastcall *off_B020)(_DWORD, _DWORD, _DWORD);

//----- (000038A0) --------------------------------------------------------
int _android_log_exception_write(const char *a1, int a2, const char *a3, const char *a4, ...)
{
  const char *v4; // r10@1
  const char *v5; // r7@1
  const char *v6; // r8@1
  size_t v7; // r0@1
  int result; // r0@1
  int v9; // [sp+4h] [bp-454h]@1
  int *v10; // [sp+8h] [bp-450h]@1
  int *v11; // [sp+Ch] [bp-44Ch]@1
  int v12; // [sp+10h] [bp-448h]@1
  const char *v13; // [sp+14h] [bp-444h]@1
  size_t v14; // [sp+18h] [bp-440h]@1
  const char *v15; // [sp+1Ch] [bp-43Ch]@1
  int v16; // [sp+20h] [bp-438h]@1
  char *v17; // [sp+24h] [bp-434h]@1
  int v18; // [sp+28h] [bp-430h]@1
  char s; // [sp+2Ch] [bp-42Ch]@1
  int v20; // [sp+42Ch] [bp-2Ch]@1
  va_list va; // [sp+458h] [bp+0h]@1

  va_start(va, a4);
  v4 = a4;
  v5 = a1;
  v6 = a3;
  v9 = a2;
  v20 = _stack_chk_guard;
  memset(&s, 0, 0x400u);
  v10 = va;
  vsnprintf(&s, 0x400u, v4, va);
  v11 = &v9;
  v13 = v6;
  v12 = 1;
  v14 = strlen(v6);
  v15 = v5;
  v7 = strlen(v5);
  v17 = &s;
  v16 = v7 + 1;
  v18 = _strlen_chk(&s, 1024) + 1;
  result = off_B020(0, &v11, 4);
  if ( v20 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 278C: using guessed type int __fastcall _strlen_chk(_DWORD, _DWORD);
// B020: using guessed type int (__fastcall *off_B020)(_DWORD, _DWORD, _DWORD);

//----- (00003948) --------------------------------------------------------
int __fastcall _android_log_exception_msg_write(const char *a1, int a2, const char *a3)
{
  return j___android_log_exception_write(a1, a2, a3, "%s");
}

//----- (00003968) --------------------------------------------------------
signed int __fastcall sub_3968(int a1)
{
  signed int result; // r0@3

  if ( a1 == 32 || a1 == 13 )
    result = 1;
  else
    result = (unsigned int)(a1 - 9) <= 1;
  return result;
}

//----- (00003980) --------------------------------------------------------
void __fastcall android_closeEventTagMap(unsigned __int64 *a1)
{
  unsigned __int64 *v1; // r4@1

  v1 = a1;
  if ( a1 )
  {
    munmap((void *)*a1, *a1 >> 32);
    j_j_free(v1);
  }
}

//----- (0000399C) --------------------------------------------------------
void *__fastcall android_openEventTagMap(const char *a1)
{
  const char *v1; // r9@1
  void *v2; // r4@1
  int v3; // r0@2
  int v4; // r1@2
  int v5; // r2@2
  FILE *v6; // r7@3
  int *v7; // r0@3
  char *v8; // ST00_4@3
  __off_t v9; // r7@4
  int v10; // r6@6
  const char *v11; // r0@6
  const char *v12; // r8@6
  FILE *v13; // r7@7
  int *v14; // r0@7
  char *v15; // ST00_4@7
  const char *v16; // r10@9
  unsigned int v17; // r7@9
  signed int v18; // r1@10
  int v19; // r0@12
  int v20; // t1@12
  void *v21; // r0@17
  signed int v22; // r6@19
  signed int v23; // r11@19
  signed int v24; // r1@19
  int v25; // r10@21
  signed int v26; // r3@29
  const char *v27; // r1@29
  FILE *v28; // r0@29
  const char *v29; // r2@29
  char *v30; // r10@30
  int v31; // t1@31
  unsigned __int32 v32; // r8@32
  int v33; // r0@35
  int v34; // t1@35
  int v35; // r0@38
  int v36; // t1@38
  int v37; // t1@46
  signed int i; // r2@58
  int v39; // r1@60
  int v40; // r3@60
  int v41; // r2@61
  int v42; // ST08_4@61
  int fd; // [sp+14h] [bp-44h]@2
  int v45; // [sp+1Ch] [bp-3Ch]@30
  char *endptr; // [sp+2Ch] [bp-2Ch]@32

  v1 = a1;
  v2 = calloc(1u, 0x10u);
  if ( !v2 )
    return 0;
  v3 = open(v1, 0);
  fd = v3;
  if ( v3 < 0 )
  {
    v6 = (FILE *)stderr;
    v7 = (int *)_errno(v3, v4, v5);
    v8 = strerror(*v7);
    fprintf(v6, "%s: unable to open map '%s': %s\n", "EventTagMap", v1, v8);
    goto LABEL_62;
  }
  v9 = lseek(v3, 0, 2);
  lseek(fd, 0, 0);
  if ( v9 < 0 )
  {
    fprintf((FILE *)stderr, "%s: unable to seek map '%s'\n", "EventTagMap", v1);
    goto LABEL_62;
  }
  v10 = 0;
  v11 = (const char *)mmap(0, v9, 3, 2, fd, 0);
  v12 = v11;
  *(_DWORD *)v2 = v11;
  if ( v11 == (const char *)-1 )
  {
    v13 = (FILE *)stderr;
    v14 = (int *)_errno(-1, &stderr, 0xFFFFFFF0);
    v15 = strerror(*v14);
    fprintf(v13, "%s: mmap(%s) failed: %s\n", "EventTagMap", v1, v15);
LABEL_62:
    j_android_closeEventTagMap((unsigned __int64 *)v2);
    if ( fd >= 0 )
      close(fd);
    return 0;
  }
  *((_DWORD *)v2 + 1) = v9;
  v16 = v11;
  v17 = (unsigned int)&v11[v9];
LABEL_10:
  v18 = 1;
  while ( (unsigned int)v16 < v17 )
  {
    v20 = *v16++;
    v19 = v20;
    if ( v20 == 10 )
      goto LABEL_10;
    if ( v18 )
    {
      if ( (unsigned int)(v19 - 48) > 9 )
      {
        v18 = sub_3968(v19) != 0;
      }
      else
      {
        ++v10;
        v18 = 0;
      }
    }
  }
  *((_DWORD *)v2 + 3) = v10;
  v21 = calloc(1u, 8 * v10);
  *((_DWORD *)v2 + 2) = v21;
  if ( !v21 )
    goto LABEL_62;
  if ( *(_BYTE *)(v17 - 1) != 10 )
  {
    fprintf((FILE *)stderr, "%s: map file missing EOL on last line\n", "EventTagMap");
LABEL_70:
    fprintf((FILE *)stderr, "%s: file parse failed\n", "EventTagMap");
    goto LABEL_62;
  }
  v22 = 1;
  v23 = 0;
  v24 = 1;
  while ( (unsigned int)v12 < v17 )
  {
    v25 = *v12;
    if ( v25 == 10 )
    {
LABEL_50:
      ++v22;
    }
    else
    {
      if ( !v24 )
        goto LABEL_23;
      if ( v25 == 35 )
      {
        v24 = 0;
        goto LABEL_23;
      }
      if ( (unsigned int)(v25 - 48) <= 9 )
      {
        if ( v23 < *((_DWORD *)v2 + 3) )
        {
          v30 = (char *)v12;
          v45 = *((_DWORD *)v2 + 2);
          do
            v31 = (unsigned __int8)(v30++)[1];
          while ( (unsigned int)(v31 - 48) <= 9 );
          *v30 = 0;
          v32 = strtoul(v12, &endptr, 10);
          if ( endptr != v30 )
            fputs("ARRRRGH\n", (FILE *)stderr);
          *(_DWORD *)(v45 + 8 * v23) = v32;
          do
          {
            v34 = (unsigned __int8)(v30++)[1];
            v33 = v34;
            if ( v34 == 10 )
            {
              v27 = "%s: missing tag string on line %d\n";
              v29 = "EventTagMap";
              v28 = (FILE *)stderr;
              goto LABEL_68;
            }
          }
          while ( sub_3968(v33) );
          *(_DWORD *)(v45 + 8 * v23 + 4) = v30;
          do
          {
            do
            {
              v36 = (unsigned __int8)(v30++)[1];
              v35 = v36;
            }
            while ( (unsigned int)(v36 - 65) <= 0x19 );
          }
          while ( (unsigned int)(v35 - 97) <= 0x19 || (unsigned int)(v35 - 48) <= 9 || v35 == 95 );
          if ( v35 == 10 )
          {
            *v30 = 0;
            v12 = v30;
LABEL_49:
            ++v23;
            goto LABEL_50;
          }
          if ( sub_3968(v35) )
          {
            v12 = v30;
            *v30 = 0;
            do
              v37 = (v12++)[1];
            while ( v37 != 10 );
            goto LABEL_49;
          }
          v27 = "%s: invalid tag chars on line %d\n";
          v29 = "EventTagMap";
          v28 = (FILE *)stderr;
LABEL_68:
          v26 = v22;
        }
        else
        {
          v26 = v23;
          v27 = "%s: more tags than expected (%d)\n";
          v28 = (FILE *)stderr;
          v29 = "EventTagMap";
        }
        fprintf(v28, v27, v29, v26);
        goto LABEL_70;
      }
      if ( !sub_3968(*v12) )
      {
        fprintf((FILE *)stderr, "%s: unexpected chars (0x%02x) in tag number on line %d\n", "EventTagMap", v25, v22);
        goto LABEL_70;
      }
    }
    v24 = 1;
LABEL_23:
    ++v12;
  }
  if ( v23 != *((_DWORD *)v2 + 3) )
  {
    fprintf((FILE *)stderr, "%s: parsed %d tags, expected %d\n", "EventTagMap", v23, *((_DWORD *)v2 + 3));
    goto LABEL_70;
  }
  qsort(*((void **)v2 + 2), v23, 8u, (__compar_fn_t)sub_3960);
  for ( i = 1; i < *((_DWORD *)v2 + 3); ++i )
  {
    v39 = *((_DWORD *)v2 + 2);
    v40 = 8 * i - 8;
    if ( *(_DWORD *)(v39 + 8 * i) == *(_DWORD *)(v39 + v40) )
    {
      v41 = *(_DWORD *)(v39 + 8 * i + 4);
      v42 = *(_DWORD *)(v39 + v40 + 4);
      fprintf((FILE *)stderr, "%s: duplicate tag entries (%d:%s and %d:%s)\n", "EventTagMap");
      goto LABEL_62;
    }
  }
  return v2;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 3960: using guessed type int sub_3960();

//----- (00003D04) --------------------------------------------------------
int __fastcall android_lookupEventTag(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r2@1
  int v4; // r5@3
  int v5; // r3@3
  int v6; // r6@3
  int v7; // r5@3

  v2 = 0;
  v3 = *(_DWORD *)(a1 + 12) - 1;
  while ( v2 <= v3 )
  {
    v4 = *(_DWORD *)(a1 + 8);
    v5 = (v2 + v3) >> 1;
    v6 = v4 + 8 * v5;
    v7 = *(_DWORD *)(v4 + 8 * v5) - a2;
    if ( v7 >= 0 )
    {
      if ( !v7 )
        return *(_DWORD *)(v6 + 4);
      v3 = v5 - 1;
    }
    else
    {
      v2 = v5 + 1;
    }
  }
  return 0;
}

//----- (00003D38) --------------------------------------------------------
int __fastcall sub_3D38(int *a1, int a2)
{
  int *v2; // r4@1
  int v3; // r0@1
  int result; // r0@2
  char v5; // [sp+0h] [bp-70h]@3
  int v6; // [sp+5Ch] [bp-14h]@1

  v2 = a1;
  v3 = *a1;
  v6 = _stack_chk_guard;
  if ( v3 || (result = _system_property_find(a2), (*v2 = result) != 0) )
  {
    result = _system_property_serial(*v2);
    if ( result != v2[1] )
    {
      v2[1] = result;
      result = _system_property_read(*v2, 0, &v5);
      *((_BYTE *)v2 + 8) = v5;
    }
  }
  if ( v6 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 2828: using guessed type int __fastcall _system_property_serial(_DWORD);
// 2834: using guessed type int __fastcall _system_property_read(_DWORD, _DWORD, _DWORD);
// 2840: using guessed type int __fastcall _system_property_find(_DWORD);

//----- (00003D90) --------------------------------------------------------
int __fastcall _android_log_is_loggable(signed int a1, const char *a2, signed int a3)
{
  signed int v3; // r9@1
  signed int v4; // r5@1
  const char *v5; // r4@1
  int v6; // r0@4
  int v7; // r0@4
  int v8; // r11@4
  int *v9; // r2@5
  int v10; // r0@6
  int v11; // r6@7
  int v12; // r4@13
  int v13; // r0@18
  int v14; // r1@22
  int result; // r0@36
  int v16; // [sp+0h] [bp+0h]@4
  int *v17; // [sp+4h] [bp+4h]@4
  int v18; // [sp+8h] [bp+8h]@15
  _BYTE savedregs[36]; // [sp+Ch] [bp+Ch]@11

  v3 = a1;
  v4 = a3;
  v5 = a2;
  if ( a2 && *a2 )
    strlen(a2);
  strcpy((char *)&v16, "persist.log.tag.");
  v6 = pthread_mutex_lock((pthread_mutex_t *)&unk_B078);
  v7 = _system_property_area_serial(v6);
  v8 = v7;
  if ( v17 )
  {
    v9 = (int *)dword_B070;
    if ( dword_B070 && (v17 = (int *)dword_B070, v10 = strcmp((const char *)dword_B070, v5), v9 = v17, !v10) )
    {
      v11 = v8;
    }
    else
    {
      v17 = (int *)-1;
      dword_B03C = 0;
      byte_B044 = 0;
      dword_B048 = 0;
      byte_B050 = 0;
      dword_B040 = -1;
      dword_B04C = -1;
      free(v9);
      dword_B070 = 0;
      v11 = (int)v17;
    }
    if ( !dword_B070 )
    {
      v17 = &dword_B070;
      dword_B070 = (int)strdup(v5);
    }
    strcpy(&savedregs[4], v5);
    if ( v8 != dword_B074 )
      sub_3D38(&dword_B03C, (int)&v16);
    v12 = (unsigned __int8)byte_B044;
    if ( !byte_B044 )
    {
      if ( v8 != dword_B074 )
        sub_3D38(&dword_B048, (int)&v18);
      v12 = (unsigned __int8)byte_B050;
    }
  }
  else
  {
    v11 = v7;
    v12 = 0;
  }
  v13 = toupper(v12);
  if ( (unsigned int)(v13 - 65) > 0x16 || !((1 << (v13 - 65)) & 0x640139) )
  {
    savedregs[3] = 0;
    if ( v11 != dword_B074 )
      sub_3D38((int *)&unk_B024, (int)&v16);
    v14 = (unsigned __int8)byte_B02C;
    if ( byte_B02C )
      goto LABEL_40;
    if ( v11 != dword_B074 )
      sub_3D38((int *)&unk_B030, (int)&v18);
    v14 = (unsigned __int8)byte_B038;
    if ( byte_B038 )
LABEL_40:
      v12 = v14;
  }
  dword_B074 = v11;
  pthread_mutex_unlock((pthread_mutex_t *)&unk_B078);
  switch ( toupper(v12) )
  {
    case 68:
      v4 = 3;
      break;
    case 73:
      v4 = 4;
      break;
    case 87:
      v4 = 5;
      break;
    case 69:
      v4 = 6;
      break;
    case 65:
    case 70:
      v4 = 7;
      break;
    case 83:
      v4 = -1;
      break;
    case 86:
      v4 = 2;
      break;
    default:
      break;
  }
  if ( v4 < 0 )
    result = 0;
  else
    result = v3 >= v4;
  return result;
}
// 284C: using guessed type int __fastcall _system_property_area_serial(_DWORD);
// B02C: using guessed type char byte_B02C;
// B038: using guessed type char byte_B038;
// B03C: using guessed type int dword_B03C;
// B040: using guessed type int dword_B040;
// B044: using guessed type char byte_B044;
// B048: using guessed type int dword_B048;
// B04C: using guessed type int dword_B04C;
// B050: using guessed type char byte_B050;
// B070: using guessed type int dword_B070;
// B074: using guessed type int dword_B074;

//----- (00003FB4) --------------------------------------------------------
int __fastcall sub_3FB4(int a1)
{
  return (*(_BYTE *)(a1 + 2) << 16) | (*(_BYTE *)(a1 + 1) << 8) | *(_BYTE *)a1 | (*(_BYTE *)(a1 + 3) << 24);
}

//----- (00003FCC) --------------------------------------------------------
int __fastcall sub_3FCC(_DWORD *a1, int *a2, char **a3, size_t *a4)
{
  _DWORD *v4; // r11@1
  int v5; // r4@1
  int *v6; // r10@1
  int v7; // r5@1
  char *v8; // r8@1
  size_t v9; // r9@1
  int v10; // r0@2
  unsigned int v11; // r1@2
  int v12; // r6@2
  int v13; // r0@4
  unsigned int v14; // r0@4
  int v15; // r1@6
  int v16; // r4@6
  int v17; // r3@6
  int v18; // r6@6
  int v19; // r2@6
  int v20; // r7@6
  int v21; // r1@6
  int v27; // r3@10
  unsigned int v28; // r0@12
  const void *v29; // r1@12
  unsigned int v30; // r7@12
  unsigned int v31; // r6@16
  int v32; // r7@19
  int v33; // r4@20
  int *v34; // r12@20
  int result; // r0@22
  char *v36; // r1@25
  char *v37; // r7@28
  int v38; // r1@34
  int v39; // r7@34
  unsigned int v40; // r4@34
  _DWORD *v41; // [sp+Ch] [bp-44h]@1
  size_t *v42; // [sp+10h] [bp-40h]@1
  int *v43; // [sp+14h] [bp-3Ch]@22
  int v44; // [sp+18h] [bp-38h]@2
  int v45; // [sp+1Ch] [bp-34h]@1
  char *v46; // [sp+20h] [bp-30h]@1
  unsigned int v47; // [sp+24h] [bp-2Ch]@1

  v4 = a1;
  v5 = *a1;
  v6 = a2;
  v42 = a4;
  v7 = *a2;
  v41 = a3;
  v8 = *a3;
  v45 = v7;
  v9 = *a4;
  v46 = v8;
  v47 = v9;
  if ( v7 )
  {
    v10 = v5 + 1;
    v11 = v7 - 1;
    v44 = v5 + 1;
    v12 = *(_BYTE *)v5;
    v45 = v7 - 1;
    switch ( v12 )
    {
      case 0:
        if ( v11 <= 3 )
          goto LABEL_32;
        v13 = sub_3FB4(v10);
        v44 = v5 + 5;
        v45 = v7 - 5;
        v14 = snprintf(v8, v9, "%d", v13);
        goto LABEL_9;
      case 1:
        if ( v11 <= 7 )
          goto LABEL_32;
        v15 = *(_BYTE *)(v5 + 7);
        v16 = v5 + 9;
        v17 = *(_BYTE *)(v16 - 7);
        v18 = (v15 << 16) | (*(_BYTE *)(v16 - 3) << 8) | *(_BYTE *)(v16 - 4) | (*(_BYTE *)(v16 - 1) << 24);
        v19 = *(_BYTE *)(v16 - 8);
        v20 = *(_BYTE *)(v16 - 6) << 16;
        v21 = *(_BYTE *)(v16 - 5);
        v45 = v7 - 9;
        v44 = v16;
        v14 = snprintf(v8, v9, "%lld");
        goto LABEL_9;
      case 4:
        if ( v11 <= 3 )
          goto LABEL_32;
        _R0 = sub_3FB4(v10);
        __asm { VMOV            S15, R0 }
        v45 = v7 - 5;
        v44 = v5 + 5;
        __asm
        {
          VCVT.F64.F32    D16, S15
          VSTR            D16, [SP,#0x50+var_50]
        }
        v14 = snprintf(v8, v9, "%f");
LABEL_9:
        if ( v14 >= v47 )
          goto LABEL_33;
        v27 = v47 - v14;
        v46 += v14;
        goto LABEL_29;
      case 2:
        if ( v11 <= 3 )
          goto LABEL_32;
        v28 = sub_3FB4(v10);
        v29 = (const void *)(v5 + 5);
        v30 = v28;
        v44 = v5 + 5;
        v45 = v7 - 5;
        if ( v7 - 5 < v28 )
          goto LABEL_32;
        if ( v28 >= v9 )
        {
          if ( v9 )
          {
            memcpy(v8, v29, v9);
            v31 = v47;
            v47 = 0;
            v46 += v31;
            goto LABEL_33;
          }
        }
        else
        {
          memcpy(v8, v29, v28);
          v46 += v30;
          v47 -= v30;
        }
        v44 += v30;
        v45 -= v30;
        goto LABEL_30;
      case 3:
        if ( v7 == 1 )
          goto LABEL_32;
        v44 = v5 + 2;
        v32 = *(_BYTE *)(v5 + 1);
        v45 = v7 - 2;
        if ( !v9 )
          goto LABEL_33;
        v33 = 0;
        v46 = v8 + 1;
        v34 = (int *)&v46;
        *v8 = 91;
        --v47;
        break;
      default:
        fprintf((FILE *)stderr, "Unknown binary event type %d\n", v12);
        goto LABEL_32;
    }
    while ( v33 < v32 )
    {
      v43 = v34;
      result = sub_3FCC(&v44, &v45, v34, &v47);
      if ( result )
        goto LABEL_34;
      v34 = v43;
      if ( v33 < v32 - 1 )
      {
        if ( !v47 )
          goto LABEL_33;
        v36 = v46++;
        *v36 = 44;
        --v47;
      }
      ++v33;
    }
    if ( !v47 )
    {
LABEL_33:
      result = 1;
      goto LABEL_34;
    }
    v37 = v46++;
    *v37 = 93;
    v27 = v47 - 1;
LABEL_29:
    v47 = v27;
LABEL_30:
    result = 0;
LABEL_34:
    v38 = v45;
    v39 = (int)v46;
    v40 = v47;
    *v4 = v44;
    *v6 = v38;
    *v41 = v39;
    *v42 = v40;
  }
  else
  {
LABEL_32:
    result = -1;
  }
  return result;
}

//----- (000041FC) --------------------------------------------------------
int __fastcall sub_41FC(char *a1, int a2, unsigned int a3)
{
  char *v3; // r9@1
  int v4; // r7@1
  unsigned int v5; // r8@1
  char *v6; // r6@1
  int v7; // r3@3
  unsigned int v8; // lr@4
  int v9; // r1@8
  signed int v10; // r0@8
  signed int v11; // r2@8
  unsigned int v12; // r4@8
  char v13; // r5@11
  const char *v14; // r2@17
  char *v15; // r0@24
  const char *v16; // r1@24
  char v17; // lr@26
  char s; // [sp+18h] [bp-30h]@20
  char v20; // [sp+20h] [bp-28h]@27

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = a1;
  while ( v5 )
  {
    v7 = *(_BYTE *)v4;
    if ( v5 > 4 )
      v8 = 5;
    else
      v8 = v5;
    if ( v7 & 0x80 )
    {
      if ( !(v7 & 0x40) )
        goto LABEL_15;
      v9 = 1;
      v10 = 64;
      v11 = 128;
      v12 = 1;
      while ( v10 & v7 )
      {
        if ( v12 <= v8 )
        {
          v13 = *(_BYTE *)(v4 + v12);
          if ( (v13 & 0xC0) == 128 )
          {
            ++v12;
            v11 |= v10;
            v9 = (v13 & 0x3F) + (v9 << 6);
            v10 >>= 1;
            if ( v12 != 5 )
              continue;
          }
        }
        goto LABEL_15;
      }
      if ( (v9 | ((v7 & ~(v11 | (unsigned int)v10)) << (6 * v12 - 6))) >= 0x110000 )
      {
LABEL_15:
        if ( v5 <= 1 )
        {
          v14 = "\\%o";
        }
        else if ( (unsigned int)*(_BYTE *)(v4 + 1) - 48 > 9 )
        {
          v14 = "\\%o";
        }
        else
        {
          v14 = "\\%03o";
        }
        snprintf(&s, 6u, v14);
        v12 = 1;
        goto LABEL_28;
      }
    }
    else
    {
      v12 = 1;
    }
    s = 0;
    if ( v12 == 1 )
    {
      switch ( v7 )
      {
        case 7:
          v15 = &s;
          v16 = "\\a";
          break;
        case 8:
          v15 = &s;
          v16 = "\\b";
          break;
        case 9:
          v15 = &s;
          v16 = "\\t";
          break;
        case 11:
          v15 = &s;
          v16 = "\\v";
          break;
        case 12:
          v15 = &s;
          v16 = "\\f";
          break;
        case 13:
          v15 = &s;
          v16 = "\\r";
          break;
        default:
          if ( v7 != 92 )
          {
            if ( (unsigned int)(v7 - 32) > 0x5F )
              snprintf(&s, 6u, "\\%o");
            goto LABEL_26;
          }
          v15 = &s;
          v16 = "\\\\";
          break;
      }
      strcpy(v15, v16);
    }
LABEL_26:
    v17 = s;
    if ( !s )
    {
      _strncpy_chk(&s, v4, v12, 6);
      *(&v20 + v12 - 8) = v17;
    }
LABEL_28:
    if ( v3 )
      strcpy(v6, &s);
    v6 += _strlen_chk(&s, 6);
    v4 += v12;
    v5 -= v12;
  }
  return v6 - v3;
}
// 278C: using guessed type int __fastcall _strlen_chk(_DWORD, _DWORD);
// 2870: using guessed type int __fastcall _strncpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000043B0) --------------------------------------------------------
_BOOL4 __fastcall android_log_shouldPrintLine(int a1, const char *a2, unsigned int a3)
{
  int *v3; // r5@1
  int v4; // r4@1
  const char *v5; // r7@1
  unsigned int v6; // r6@1
  unsigned int v7; // r0@4

  v3 = (int *)a1;
  v4 = *(_DWORD *)(a1 + 4);
  v5 = a2;
  v6 = a3;
  while ( v4 )
  {
    if ( !strcmp(v5, *(const char **)v4) )
    {
      v7 = *(_DWORD *)(v4 + 4);
      if ( v7 != 1 )
        return v6 >= v7;
      break;
    }
    v4 = *(_DWORD *)(v4 + 8);
  }
  v7 = *v3;
  return v6 >= v7;
}

//----- (000043DE) --------------------------------------------------------
_DWORD *android_log_format_new()
{
  _DWORD *result; // r0@1

  result = calloc(1u, 0x10u);
  *result = 2;
  result[2] = 1;
  *((_BYTE *)result + 12) = 0;
  *((_BYTE *)result + 13) = 0;
  *((_BYTE *)result + 14) = 0;
  return result;
}

//----- (000043FA) --------------------------------------------------------
void __fastcall android_log_format_free(void *ptr)
{
  void *v1; // r4@1
  int i; // r0@1
  int v3; // r5@3

  v1 = ptr;
  for ( i = *((_DWORD *)ptr + 1); i; i = v3 )
  {
    v3 = *(_DWORD *)(i + 8);
    free((void *)i);
  }
  j_j_free(v1);
}

//----- (00004416) --------------------------------------------------------
signed int __fastcall android_log_setPrintFormat(int a1, int a2)
{
  if ( a2 == 10 )
  {
    *(_BYTE *)(a1 + 13) = 1;
    return 0;
  }
  if ( a2 == 11 )
  {
    *(_BYTE *)(a1 + 14) = 1;
    return 0;
  }
  if ( a2 == 9 )
  {
    *(_BYTE *)(a1 + 12) = 1;
    return 0;
  }
  *(_DWORD *)(a1 + 8) = a2;
  return 1;
}

//----- (0000443C) --------------------------------------------------------
int __fastcall android_log_formatFromString(const char *a1)
{
  const char *v1; // r4@1
  signed int v2; // r2@2
  int *v3; // r3@2

  v1 = a1;
  if ( !strcmp(a1, "brief") )
  {
    v2 = 1;
    v3 = &dword_B07C;
  }
  else if ( !strcmp(v1, "process") )
  {
    v2 = 2;
    v3 = &dword_B07C;
  }
  else if ( !strcmp(v1, "tag") )
  {
    v2 = 3;
    v3 = &dword_B07C;
  }
  else if ( !strcmp(v1, "thread") )
  {
    v2 = 4;
    v3 = &dword_B07C;
  }
  else if ( !strcmp(v1, "raw") )
  {
    v2 = 5;
    v3 = &dword_B07C;
  }
  else if ( !strcmp(v1, "time") )
  {
    v2 = 6;
    v3 = &dword_B07C;
  }
  else if ( !strcmp(v1, "threadtime") )
  {
    v2 = 7;
    v3 = &dword_B07C;
  }
  else if ( !strcmp(v1, "long") )
  {
    v2 = 8;
    v3 = &dword_B07C;
  }
  else if ( !strcmp(v1, "color") )
  {
    v2 = 9;
    v3 = &dword_B07C;
  }
  else if ( !strcmp(v1, "usec") )
  {
    v2 = 10;
    v3 = &dword_B07C;
  }
  else if ( !strcmp(v1, "printable") )
  {
    v2 = 11;
    v3 = &dword_B07C;
  }
  else
  {
    v2 = 0;
    v3 = &dword_B07C;
  }
  *v3 = v2;
  return dword_B07C;
}
// B07C: using guessed type int dword_B07C;

//----- (0000458C) --------------------------------------------------------
int __fastcall android_log_addFilterRule(int a1, const char *a2)
{
  int v2; // r7@1
  const char *v3; // r5@1
  size_t v4; // r0@1
  size_t v5; // r6@1
  unsigned __int8 v6; // r0@3
  int v7; // r4@3
  int result; // r0@16
  char *v9; // r0@22
  const char *v10; // r8@22
  _DWORD *v11; // r6@22
  int v12; // r3@22

  v2 = a1;
  v3 = a2;
  v4 = strcspn(a2, ":");
  v5 = v4;
  if ( !v4 )
    return -1;
  if ( v3[v4] != 58 )
    goto LABEL_15;
  v6 = tolower(v3[v4 + 1]);
  v7 = v6 - 48;
  if ( (unsigned __int8)v7 > 9u )
  {
    if ( v6 == 118 )
      goto LABEL_24;
    if ( v6 == 100 )
    {
      v7 = 3;
      goto LABEL_16;
    }
    if ( v6 == 105 )
    {
      v7 = 4;
      goto LABEL_16;
    }
    if ( v6 == 119 )
    {
      v7 = 5;
      goto LABEL_16;
    }
    if ( v6 == 101 )
    {
      v7 = 6;
      goto LABEL_16;
    }
    if ( v6 == 102 )
    {
      v7 = 7;
      goto LABEL_16;
    }
    if ( v6 == 115 )
    {
      v7 = 8;
      goto LABEL_16;
    }
    if ( v6 != 42 )
      return -1;
LABEL_15:
    v7 = 1;
    goto LABEL_16;
  }
  if ( v6 > 0x37u )
  {
LABEL_24:
    v7 = 2;
    goto LABEL_16;
  }
  if ( v6 == 48 )
    return -1;
LABEL_16:
  result = strncmp("*", v3, v5);
  if ( result )
  {
    if ( v7 == 1 )
      v7 = 2;
    v9 = strdup(v3);
    v10 = v9;
    v9[v5] = 0;
    v11 = calloc(1u, 0xCu);
    *v11 = strdup(v10);
    v11[1] = v7;
    free((void *)v10);
    v12 = *(_DWORD *)(v2 + 4);
    result = 0;
    *(_DWORD *)(v2 + 4) = v11;
    v11[2] = v12;
  }
  else
  {
    if ( v7 == 1 )
      v7 = 3;
    *(_DWORD *)v2 = v7;
  }
  return result;
}

//----- (00004668) --------------------------------------------------------
signed int __fastcall android_log_addFilterString(int a1, const char *a2)
{
  int v2; // r8@1
  char *v3; // r5@1
  char *v4; // r0@2
  char *v5; // r4@2
  char *v7; // [sp+4h] [bp-1Ch]@1

  v2 = a1;
  v3 = strdup(a2);
  v7 = v3;
  while ( 1 )
  {
    v4 = strsep(&v7, " \t,");
    v5 = v4;
    if ( !v4 )
      break;
    if ( *v4 && j_android_log_addFilterRule(v2, v4) < 0 )
    {
      free(v3);
      return -1;
    }
  }
  free(v3);
  return (signed int)v5;
}

//----- (000046BC) --------------------------------------------------------
signed int __fastcall android_log_processLogBuffer(int a1, int a2)
{
  unsigned int v2; // r2@1
  FILE **v3; // r1@2
  const char *v4; // r0@2
  signed int result; // r0@3
  int v6; // r3@5
  int v7; // r0@7
  int v8; // r4@7
  _BYTE *v9; // r2@16
  int v10; // r3@16
  int v11; // t1@16
  int v12; // r4@16

  *(_DWORD *)a2 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 8);
  v2 = *(_WORD *)a1;
  if ( v2 > 2 )
  {
    if ( *(_WORD *)(a1 + 2) )
      v6 = *(_WORD *)(a1 + 2) + a1;
    else
      v6 = a1 + 20;
    v7 = 1;
    v8 = -1;
    while ( v7 < (signed int)v2 )
    {
      if ( !*(_BYTE *)(v6 + v7) )
      {
        if ( v8 != -1 )
          goto LABEL_16;
        v8 = v7 + 1;
      }
      ++v7;
    }
    if ( v8 == -1 )
    {
      v3 = (FILE **)&stderr;
      v4 = "+++ LOG: malformed log message\n";
      goto LABEL_3;
    }
    v7 = v2 - 1;
    *(_BYTE *)(v6 + v2 - 1) = 0;
LABEL_16:
    v9 = (_BYTE *)v6;
    v10 = v6 + v8;
    v11 = *v9;
    v12 = v7 - v8;
    result = 0;
    *(_DWORD *)(a2 + 28) = v10;
    *(_DWORD *)(a2 + 24) = v12;
    *(_DWORD *)(a2 + 8) = v11;
    *(_DWORD *)(a2 + 20) = v9 + 1;
  }
  else
  {
    v3 = (FILE **)&stderr;
    v4 = "+++ LOG: entry too small\n";
LABEL_3:
    fputs(v4, *v3);
    result = -1;
  }
  return result;
}

//----- (0000474C) --------------------------------------------------------
signed int __fastcall android_log_processBinaryLogBuffer(int a1, _DWORD *a2, char *a3, int a4, size_t a5)
{
  char *v5; // r5@1
  _DWORD *v6; // r4@1
  int v7; // r9@1
  int v8; // r6@1
  int v9; // r1@1
  int v10; // r3@1
  unsigned int v11; // r7@3
  int v12; // r10@4
  int v13; // r0@8
  int v14; // r0@9
  char *v15; // r1@9
  char *v16; // r0@12
  bool v17; // cf@12
  bool v18; // zf@12
  signed int result; // r0@26
  char *v20; // r1@26
  int v21; // [sp+0h] [bp-30h]@1
  _BYTE *v22; // [sp+4h] [bp-2Ch]@1
  char *v23; // [sp+8h] [bp-28h]@1
  char *v24; // [sp+Ch] [bp-24h]@1

  v21 = a1;
  v22 = a2;
  v23 = a3;
  v24 = (char *)a4;
  v5 = (char *)a4;
  v6 = a2;
  v7 = (int)a3;
  v8 = a5;
  *a2 = *(_DWORD *)(a1 + 12);
  v9 = *(_DWORD *)(a1 + 16);
  v6[2] = 4;
  v6[1] = v9;
  v6[3] = *(_DWORD *)(a1 + 4);
  v10 = *(_DWORD *)(a1 + 8);
  v22 = (_BYTE *)(a1 + 20);
  v6[4] = v10;
  if ( *(_WORD *)(a1 + 2) )
    v22 = (_BYTE *)(*(_WORD *)(a1 + 2) + a1);
  v11 = *(_WORD *)a1;
  v21 = *(_WORD *)a1;
  if ( v11 <= 3 )
    return -1;
  v12 = sub_3FB4((int)v22);
  v21 = v11 - 4;
  v22 += 4;
  if ( v7 )
    v6[5] = j_android_lookupEventTag(v7, v12);
  else
    v6[5] = 0;
  if ( !v6[5] )
  {
    v13 = snprintf(v5, a5, "[%d]", v12, v21);
    v6[5] = v5;
    v8 = a5 + ~v13;
    v5 += v13 + 1;
  }
  v23 = v5;
  v24 = (char *)(v8 - 1);
  v14 = sub_3FCC(&v22, &v21, &v23, (size_t *)&v24);
  if ( v14 < 0 )
  {
    fputs("Binary log entry conversion failed\n", (FILE *)stderr);
    return -1;
  }
  if ( v14 == 1 )
  {
    v16 = v23;
    v17 = v23 >= v5;
    v18 = v23 == v5;
    if ( v23 > v5 )
      *(v23 - 1) = 33;
    else
      v15 = v23 + 1;
    if ( v18 || !v17 )
      v23 = v15;
    if ( v18 || !v17 )
    {
      *v16 = 33;
      v16 = v24;
    }
    v21 = 0;
    if ( v18 || !v17 )
      v24 = v16 - 1;
  }
  if ( v21 == 1 && *v22 == 10 )
  {
    ++v22;
    v21 = 0;
  }
  if ( v21 )
    fprintf((FILE *)stderr, "Warning: leftover binary log data (%zu bytes)\n");
  result = 0;
  *v23 = 0;
  v20 = v23;
  v6[7] = v5;
  v6[6] = v20 - v5;
  return result;
}

//----- (00004874) --------------------------------------------------------
char *__fastcall android_log_formatLogLine(int a1, int a2, int a3, time_t *timer, int a5)
{
  time_t *v5; // r4@1
  char *v6; // r8@1
  int v7; // r10@1
  time_t v8; // r1@1
  signed int v9; // r9@2
  struct tm *v10; // r0@4
  int v11; // r3@4
  signed int v12; // r5@5
  const char *v13; // r2@5
  signed int v14; // r5@7
  time_t v15; // r0@8
  signed int v16; // r3@9
  unsigned int v17; // r0@11
  unsigned int v18; // r6@13
  unsigned int v19; // r9@16
  char *v20; // r0@16
  const char *v21; // r1@16
  unsigned int v22; // r0@17
  unsigned int v23; // r5@18
  signed int v24; // r7@25
  char *v25; // r0@25
  int v26; // r6@30
  unsigned int v27; // r1@35
  signed int v28; // r2@35
  _BYTE *v29; // r11@35
  int v30; // t1@37
  int v31; // r9@44
  int v32; // r0@45
  size_t v33; // r0@47
  char *v34; // r2@49
  int v35; // r9@50
  char *v36; // r6@51
  const char *v37; // r1@51
  unsigned int v38; // r2@51
  char *v39; // r6@52
  char *v40; // r11@55
  char *v41; // r7@55
  char *v42; // r0@57
  unsigned int v43; // r7@57
  char *v44; // r9@57
  int v45; // r9@58
  char *v46; // r0@59
  unsigned int v47; // r1@62
  char *result; // r0@67
  char *v49; // [sp+18h] [bp-188h]@1
  char *v50; // [sp+24h] [bp-17Ch]@57
  struct tm tp; // [sp+28h] [bp-178h]@4
  char s[32]; // [sp+54h] [bp-14Ch]@4
  char src[128]; // [sp+74h] [bp-12Ch]@11
  char v54[128]; // [sp+F4h] [bp-ACh]@13
  int v55; // [sp+174h] [bp-2Ch]@1

  v5 = timer;
  v6 = (char *)a2;
  v49 = (char *)a3;
  v7 = a1;
  v8 = timer[2];
  v55 = _stack_chk_guard;
  if ( v8 - 2 > 6 )
    v9 = 63;
  else
    v9 = (unsigned __int8)aVdiwefs[v8 - 2];
  v10 = localtime_r(timer, &tp);
  strftime(s, 0x20u, "%m-%d %H:%M:%S", v10);
  v11 = _strlen_chk(s, 32);
  if ( *(_BYTE *)(v7 + 13) )
  {
    v12 = 1000;
    v13 = ".%06ld";
  }
  else
  {
    v12 = 1000000;
    v13 = ".%03ld";
  }
  snprintf(&s[v11], 32 - v11, v13, (signed int)v5[1] / v12);
  v14 = *(_BYTE *)(v7 + 12);
  if ( *(_BYTE *)(v7 + 12) )
  {
    v15 = v5[2];
    if ( v15 - 3 > 4 )
      v16 = 231;
    else
      v16 = (unsigned __int8)aKJ[v15 - 3];
    v14 = 4;
    v17 = snprintf(src, 0x80u, "\x1B[38;5;%dm", v16);
    if ( v17 >= 0x80 )
      v17 = 128;
    v18 = v17;
    strcpy(v54, "\x1B[0m");
  }
  else
  {
    v18 = *(_BYTE *)(v7 + 12);
  }
  switch ( *(_DWORD *)(v7 + 8) )
  {
    case 3:
      v19 = snprintf(&src[v18], 128 - v18, "%c/%-8s: ", v9, v5[5]);
      v20 = &v54[v14];
      v21 = "\n";
      goto LABEL_27;
    case 2:
      v22 = snprintf(&v54[v14], 128 - v14, "  (%s)\n", v5[5]);
      if ( v22 > 128 - v14 )
        v23 = 128;
      else
        v23 = v14 + v22;
      v19 = snprintf(&src[v18], 128 - v18, "%c(%5d) ", v9, v5[3]);
      goto LABEL_28;
    case 4:
      v19 = snprintf(&src[v18], 128 - v18, "%c(%5d:%5d) ", v9, v5[3], v5[4]);
      v20 = &v54[v14];
      v21 = "\n";
      goto LABEL_27;
    case 5:
      v19 = 0;
      v20 = &v54[v14];
      src[v18] = 0;
      v21 = "\n";
      goto LABEL_27;
    case 6:
      v19 = snprintf(&src[v18], 128 - v18, "%s %c/%-8s(%5d): ", s, v9, v5[5], v5[3]);
      v20 = &v54[v14];
      v21 = "\n";
      goto LABEL_27;
    case 7:
      v19 = snprintf(&src[v18], 128 - v18, "%s %5d %5d %c %-8s: ", s, v5[3], v5[4], v9, v5[5]);
      v20 = &v54[v14];
      v21 = "\n";
      goto LABEL_27;
    case 8:
      v24 = 1;
      v19 = snprintf(&src[v18], 128 - v18, "[ %s %5d:%5d %c/%-8s ]\n", s, v5[3], v5[4], v9, v5[5]);
      v25 = &v54[v14];
      v23 = v14 + 2;
      strcpy(v25, "\n\n");
      break;
    default:
      v19 = snprintf(&src[v18], 128 - v18, "%c/%-8s(%5d): ", v9, v5[5], v5[3]);
      v20 = &v54[v14];
      v21 = "\n";
LABEL_27:
      v23 = v14 + 1;
      strcpy(v20, v21);
LABEL_28:
      v24 = 0;
      break;
  }
  if ( v19 > 127 - v18 )
    v26 = 127;
  else
    v26 = v18 + v19;
  if ( v23 >= 0x80 )
    v23 = 128;
  if ( v24 )
  {
    v28 = 1;
  }
  else
  {
    v27 = v5[7];
    v28 = 0;
    v29 = (_BYTE *)v5[7];
    while ( (unsigned int)v29 < v27 + v5[6] )
    {
      v30 = *v29++;
      if ( v30 == 10 )
        ++v28;
    }
    if ( (unsigned int)v29 > v27 && *(v29 - 1) != 10 )
      ++v28;
  }
  v31 = (v26 + v23) * v28 + 1;
  if ( *(_BYTE *)(v7 + 14) )
    v32 = sub_41FC(0, v5[7], v5[6]);
  else
    v32 = v5[6];
  v33 = v32 + v31;
  if ( (unsigned int)v49 >= v33 || (v6 = (char *)malloc(v33)) != 0 )
  {
    *v6 = 0;
    v34 = (char *)v5[7];
    if ( v24 )
    {
      strcat(v6, src);
      v36 = &v6[v26];
      v37 = (const char *)v5[7];
      v38 = v5[6];
      if ( *(_BYTE *)(v7 + 14) )
      {
        v39 = &v36[sub_41FC(v36, (int)v37, v38)];
      }
      else
      {
        strncat(v36, v37, v38);
        v39 = &v36[v5[6]];
      }
      strcat(v39, v54);
      v35 = (int)&v39[v23];
    }
    else
    {
      v35 = (int)v6;
      while ( 1 )
      {
        v47 = v5[7] + v5[6];
        if ( (unsigned int)v34 >= v47 )
          break;
        v41 = v34;
        do
        {
          v40 = v41++;
          if ( *v40 == 10 )
            break;
          v40 = v41;
        }
        while ( v41 != (char *)v47 );
        v42 = (char *)v35;
        v43 = v40 - v34;
        v50 = v34;
        v44 = (char *)(v35 + v26);
        strcat(v42, src);
        if ( *(_BYTE *)(v7 + 14) )
        {
          v45 = (int)&v44[sub_41FC(v44, (int)v50, v43)];
        }
        else
        {
          strncat(v44, v50, v43);
          v45 = (int)&v44[v43];
        }
        v46 = (char *)v45;
        v35 = v45 + v23;
        strcat(v46, v54);
        if ( *v40 == 10 )
          ++v40;
        v34 = v40;
      }
    }
    if ( a5 )
      *(_DWORD *)a5 = v35 - (_DWORD)v6;
  }
  result = v6;
  if ( v55 != _stack_chk_guard )
    _stack_chk_fail(v6);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 278C: using guessed type int __fastcall _strlen_chk(_DWORD, _DWORD);
// 4874: using guessed type char s[32];
// 4874: using guessed type char src[128];
// 4874: using guessed type char var_AC[128];

//----- (00004C34) --------------------------------------------------------
signed int __fastcall android_log_printLogLine(int a1, int a2, time_t *a3)
{
  int v3; // r10@1
  char *v4; // r5@1
  ssize_t v5; // r0@2
  int v6; // r1@2
  int v7; // r2@2
  signed int v8; // r4@2
  _DWORD *v9; // r0@3
  signed int result; // r0@7
  size_t v11; // [sp+8h] [bp-228h]@1
  char v12; // [sp+Ch] [bp-224h]@1
  int v13; // [sp+20Ch] [bp-24h]@1

  v3 = a2;
  v13 = _stack_chk_guard;
  v4 = j_android_log_formatLogLine(a1, (int)&v12, 512, a3, (int)&v11);
  if ( v4 )
  {
    while ( 1 )
    {
      v5 = write(v3, v4, v11);
      v8 = v5;
      if ( v5 >= 0 )
        break;
      v9 = (_DWORD *)_errno(v5, v6, v7);
      if ( *v9 != 4 )
      {
        v8 = 0;
        fprintf((FILE *)stderr, "+++ LOG: write failed (errno=%d)\n", *v9);
        goto LABEL_5;
      }
    }
    if ( v5 < v11 )
      fprintf((FILE *)stderr, "+++ LOG: write partial (%d of %d)\n", v5);
LABEL_5:
    if ( v4 != &v12 )
      free(v4);
    result = v8;
  }
  else
  {
    result = -1;
  }
  if ( v13 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00004CF0) --------------------------------------------------------
ssize_t __fastcall sub_4CF0(__int64 a1, int a2)
{
  ssize_t result; // r0@2
  int v3; // r1@2
  int v4; // r2@2
  __int64 v5; // [sp+0h] [bp-18h]@1
  int v6; // [sp+8h] [bp-10h]@1

  v6 = a2;
  v5 = a1;
  do
  {
    result = write(dword_B054, &v5, 8u);
    if ( result >= 0 )
      break;
    result = -*(_DWORD *)_errno(result, v3, v4);
  }
  while ( result == -4 );
  return result;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// B054: using guessed type int dword_B054;

//----- (00004D20) --------------------------------------------------------
int __fastcall sub_4D20(int a1, int a2)
{
  int v2; // r6@1
  int v3; // r5@1
  int (__fastcall *v4)(__int64); // r0@3

  v2 = a1;
  v3 = a2;
  if ( off_B058 == sub_4D20 )
  {
    dword_B054 = open("/dev/hwlog_jank", 524289);
    if ( dword_B054 >= 0 )
    {
      v4 = sub_4D90;
    }
    else
    {
      dword_B054 = -1;
      v4 = (int (__fastcall *)(__int64))sub_4CE8;
    }
    off_B058 = (int (__fastcall *)(_DWORD, _DWORD))v4;
  }
  return off_B058(v2, v3);
}
// 4CE8: using guessed type int sub_4CE8();
// B054: using guessed type int dword_B054;
// B058: using guessed type int (__fastcall *off_B058)(_DWORD, _DWORD);

//----- (00004D90) --------------------------------------------------------
int __fastcall sub_4D90(__int64 iovec)
{
  __int64 v1; // r4@1
  int result; // r0@2
  int v3; // r1@2
  int v4; // r2@2

  v1 = iovec;
  do
  {
    result = writev(dword_B054, (const struct iovec *)v1, SHIDWORD(v1));
    if ( result >= 0 )
      break;
    result = -*(_DWORD *)_errno(result, v3, v4);
    if ( result == -22 )
    {
      off_B058 = (int (__fastcall *)(_DWORD, _DWORD))sub_4CF0;
      return sub_4CF0(v1, (int)&off_B058);
    }
  }
  while ( result == -4 );
  return result;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// B054: using guessed type int dword_B054;
// B058: using guessed type int (__fastcall *off_B058)(_DWORD, _DWORD);

//----- (00004DE0) --------------------------------------------------------
int __fastcall _android_janklog_buf_write(__int16 a1, int a2, int a3)
{
  const char *v3; // r4@1
  signed __int64 v4; // r0@1
  __int16 v6; // [sp+4h] [bp-44h]@1
  __int16 v7; // [sp+6h] [bp-42h]@1
  __int64 v8; // [sp+8h] [bp-40h]@1
  __int64 v9; // [sp+10h] [bp-38h]@1
  __int16 *v10; // [sp+18h] [bp-30h]@1
  int v11; // [sp+1Ch] [bp-2Ch]@1
  __int16 *v12; // [sp+20h] [bp-28h]@1
  int v13; // [sp+24h] [bp-24h]@1
  __int64 *v14; // [sp+28h] [bp-20h]@1
  int v15; // [sp+2Ch] [bp-1Ch]@1
  __int64 *v16; // [sp+30h] [bp-18h]@1
  int v17; // [sp+34h] [bp-14h]@1
  const char *v18; // [sp+38h] [bp-10h]@1
  size_t v19; // [sp+3Ch] [bp-Ch]@1

  v3 = (const char *)a3;
  v7 = a1;
  v6 = a2;
  v4 = j_systemTime(1, a2, a3);
  v8 = v4 / 1000000;
  v9 = j_systemTime(4, (unsigned __int64)(v4 / 1000000) >> 32, v4 % 1000000) / 1000000;
  v18 = v3;
  v11 = 2;
  v13 = 2;
  v10 = &v7;
  v16 = &v9;
  v12 = &v6;
  v14 = &v8;
  v15 = 8;
  v17 = 8;
  v19 = strlen(v3) + 1;
  return off_B058(&v10, 5);
}
// B058: using guessed type int (__fastcall *off_B058)(_DWORD, _DWORD);

//----- (00004E58) --------------------------------------------------------
int __fastcall _android_janklog_chgtm_buf_write(__int16 a1, int a2, __int64 s, char a4, int a5, char *sa)
{
  __int64 v7; // [sp+0h] [bp-40h]@1
  __int16 v8; // [sp+Ch] [bp-34h]@1
  __int16 v9; // [sp+Eh] [bp-32h]@1
  __int16 *v10; // [sp+10h] [bp-30h]@1
  int v11; // [sp+14h] [bp-2Ch]@1
  __int16 *v12; // [sp+18h] [bp-28h]@1
  int v13; // [sp+1Ch] [bp-24h]@1
  __int64 *v14; // [sp+20h] [bp-20h]@1
  int v15; // [sp+24h] [bp-1Ch]@1
  char *v16; // [sp+28h] [bp-18h]@1
  int v17; // [sp+2Ch] [bp-14h]@1
  char *v18; // [sp+30h] [bp-10h]@1
  size_t v19; // [sp+34h] [bp-Ch]@1

  v7 = s;
  v9 = a1;
  v8 = a2;
  v11 = 2;
  v13 = 2;
  v12 = &v8;
  v15 = 8;
  v17 = 8;
  v10 = &v9;
  v16 = &a4;
  v18 = sa;
  v14 = &v7;
  v19 = strlen(sa) + 1;
  return off_B058(&v10, 5);
}
// B058: using guessed type int (__fastcall *off_B058)(_DWORD, _DWORD);

//----- (00004EB0) --------------------------------------------------------
int _android_janklog_print(__int16 a1, int a2, const char *a3, ...)
{
  int v3; // r6@1
  __int16 v4; // r7@1
  int result; // r0@1
  char s; // [sp+4h] [bp-424h]@1
  int v7; // [sp+404h] [bp-24h]@1
  va_list va; // [sp+424h] [bp-4h]@1

  va_start(va, a3);
  v3 = a2;
  v4 = a1;
  v7 = _stack_chk_guard;
  vsnprintf(&s, 0x400u, a3, va);
  result = j___android_janklog_buf_write(v4, v3, (int)&s);
  if ( v7 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00004F08) --------------------------------------------------------
int _android_janklog_chgtm_print(__int16 a1, int a2, __int64 format, char a4, int a5, char *formata, ...)
{
  __int64 v6; // r6@1
  __int16 v7; // r9@1
  int v8; // r8@1
  int result; // r0@1
  char s; // [sp+14h] [bp-424h]@1
  int v11; // [sp+414h] [bp-24h]@1
  va_list va; // [sp+444h] [bp+Ch]@1

  va_start(va, formata);
  v6 = format;
  v7 = a1;
  v8 = a2;
  v11 = _stack_chk_guard;
  vsnprintf(&s, 0x400u, formata, va);
  result = j___android_janklog_chgtm_buf_write(v7, v8, v6, a4, a5, &s);
  if ( v11 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00004F70) --------------------------------------------------------
int __fastcall sub_4F70(int a1, unsigned __int32 a2, int a3)
{
  unsigned __int32 v3; // r5@1
  int v5; // r0@5
  int v6; // r4@5
  int v7; // r5@6

  v3 = a2;
  if ( a1 )
  {
    if ( (a3 & 3) == 2 || !((*(_DWORD *)a1 ^ a3) << 30) )
      return j_j_ioctl(*(_DWORD *)(a1 + 4), a2);
    v5 = _open_2("/dev/hwlog_jank", a3);
    v6 = v5;
    if ( v5 >= 0 )
    {
      v7 = ioctl(v5, v3);
      close(v6);
      v6 = v7;
    }
  }
  else
  {
    v6 = -14;
  }
  return v6;
}
// 2930: using guessed type int __fastcall _open_2(_DWORD, _DWORD);

//----- (00004FC0) --------------------------------------------------------
unsigned int __fastcall hw_janklog_processLogBuffer(int a1, int a2)
{
  unsigned int result; // r0@2
  int v3; // r3@4
  int v4; // lr@6
  unsigned int v5; // r4@6
  __int64 v6; // r6@6
  int v7; // r3@7

  if ( (unsigned int)*(_WORD *)a1 > 0x13 )
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 8);
    if ( *(_WORD *)(a1 + 2) )
      v3 = *(_WORD *)(a1 + 2) + a1;
    else
      v3 = a1 + 20;
    v4 = *(_WORD *)a1;
    *(_DWORD *)(a2 + 8) = *(_BYTE *)v3 | (*(_BYTE *)(v3 + 1) << 8);
    *(_DWORD *)(a2 + 24) = *(_BYTE *)(v3 + 2) | (*(_BYTE *)(v3 + 3) << 8);
    v5 = 0;
    HIDWORD(v6) = (*(_BYTE *)(v3 + 10) << 16) | (*(_BYTE *)(v3 + 9) << 8) | *(_BYTE *)(v3 + 8) | (*(_BYTE *)(v3 + 11) << 24);
    LODWORD(v6) = (*(_BYTE *)(v3 + 6) << 16) | (*(_BYTE *)(v3 + 5) << 8) | *(_BYTE *)(v3 + 4) | (*(_BYTE *)(v3 + 7) << 24);
    *(_QWORD *)(a2 + 32) = v6;
    HIDWORD(v6) = (*(_BYTE *)(v3 + 18) << 16) | (*(_BYTE *)(v3 + 17) << 8) | *(_BYTE *)(v3 + 16) | (*(_BYTE *)(v3 + 19) << 24);
    LODWORD(v6) = (*(_BYTE *)(v3 + 14) << 16) | (*(_BYTE *)(v3 + 13) << 8) | *(_BYTE *)(v3 + 12) | (*(_BYTE *)(v3 + 15) << 24);
    result = v4 - 20;
    *(_QWORD *)(a2 + 40) = v6;
    if ( v4 == 20 )
    {
      *(_DWORD *)(a2 + 48) = result;
      *(_DWORD *)(a2 + 52) = result;
    }
    else
    {
      v7 = v3 + 20;
      while ( v5 < result )
      {
        if ( !*(_BYTE *)(v7 + v5) )
        {
          if ( v5 != -1 )
            goto LABEL_15;
          break;
        }
        ++v5;
      }
      v5 = v4 - 21;
      *(_BYTE *)(v7 + v4 - 21) = 0;
LABEL_15:
      *(_DWORD *)(a2 + 52) = v7;
      result = 0;
      *(_DWORD *)(a2 + 48) = v5;
    }
  }
  else
  {
    fputs("+++ LOG: entry too small\n", (FILE *)stderr);
    result = -1;
  }
  return result;
}

//----- (000050B4) --------------------------------------------------------
signed int __fastcall android_log_processBinaryJlogBuffer(int a1, int a2, char *a3, size_t a4)
{
  int v4; // r4@1
  char *v5; // r6@1
  size_t v6; // r7@1
  int v7; // r3@2
  int v8; // r0@2
  int v9; // r1@2
  int v10; // r5@2
  int v11; // r3@2
  int v12; // r0@2
  __int64 v13; // r2@2
  char *v14; // r5@2
  signed int result; // r0@2
  int v16; // [sp+8h] [bp-50h]@1
  int v17; // [sp+Ch] [bp-4Ch]@2
  int v18; // [sp+10h] [bp-48h]@2
  int v19; // [sp+14h] [bp-44h]@2
  int v20; // [sp+18h] [bp-40h]@2
  int v21; // [sp+20h] [bp-38h]@2
  __int64 v22; // [sp+28h] [bp-30h]@2
  int v23; // [sp+3Ch] [bp-1Ch]@2

  v4 = a2;
  v5 = a3;
  v6 = a4;
  if ( (j_hw_janklog_processLogBuffer(a1, (int)&v16) & 0x80000000) != 0 )
  {
    result = -1;
  }
  else
  {
    v7 = v16;
    v8 = v17;
    v9 = v19;
    v10 = v18;
    *(_DWORD *)(v4 + 16) = v20;
    *(_DWORD *)v4 = v7;
    *(_DWORD *)(v4 + 4) = v8;
    v11 = v21;
    *(_DWORD *)(v4 + 12) = v9;
    *(_DWORD *)(v4 + 8) = v10;
    v12 = snprintf(v5, v6, "[JLOG%d]", v11);
    v13 = v22;
    v14 = &v5[v12 + 1];
    *(_DWORD *)(v4 + 20) = v5;
    *(_DWORD *)(v4 + 24) = snprintf(v14, ~v12 + v6, "%s#T:%llu", v23, v13);
    result = 0;
    *(_DWORD *)(v4 + 28) = v14;
  }
  return result;
}

//----- (00005120) --------------------------------------------------------
unsigned int __fastcall hwlog_is_janklog(const char *a1)
{
  return __clz(strcmp(a1, "jank")) >> 5;
}

//----- (00005138) --------------------------------------------------------
void __fastcall hwlog_print_janklog(int a1)
{
  int v1; // r4@1
  int v2; // r0@1
  int v3; // r1@1
  int v4; // r2@1
  int *v5; // r0@2
  FILE *v6; // r4@2
  char *v7; // r0@2
  int v8; // r0@5
  const char *v9; // r0@11
  int v10; // r9@13
  unsigned int v11; // r0@15
  unsigned int v12; // r1@17
  unsigned int v13; // r2@17
  signed int v14; // r4@17
  int v15; // r6@20
  unsigned int v16; // r4@23
  signed int v17; // r7@23
  int v18; // r6@26
  int v19; // r11@31
  char v20; // r3@35
  int *v21; // r0@40
  int v22; // r1@40
  int v23; // r2@40
  signed int v24; // r3@45
  ssize_t v25; // r0@48
  int v26; // r1@48
  int v27; // r2@48
  signed int *v28; // r0@50
  int v29; // r0@56
  unsigned int v30; // r3@61
  int v31; // r4@65
  bool v32; // nf@65
  const char *v33; // r0@72
  FILE *v34; // r1@72
  struct pollfd v35; // [sp+10h] [bp-1868h]@30
  signed __int16 v36; // [sp+14h] [bp-1864h]@30
  __int16 v37; // [sp+16h] [bp-1862h]@30
  __int16 v38; // [sp+18h] [bp-1860h]@1
  int v39; // [sp+1Ch] [bp-185Ch]@1
  int v40; // [sp+24h] [bp-1854h]@53
  int v41; // [sp+28h] [bp-1850h]@55
  unsigned int v42; // [sp+30h] [bp-1848h]@56
  const char *v43; // [sp+3Ch] [bp-183Ch]@56
  char v44; // [sp+48h] [bp-1830h]@55
  char s[5112]; // [sp+448h] [bp-1430h]@33
  int v46; // [sp+44Ch] [bp-142Ch]@54
  int v47; // [sp+184Ch] [bp-2Ch]@1

  v1 = a1;
  v47 = _stack_chk_guard;
  memset(&v38, 0, 0x10u);
  *(_DWORD *)&v38 = *(_DWORD *)(v1 + 8);
  v2 = _open_2("/dev/hwlog_jank", *(_DWORD *)&v38);
  v39 = v2;
  if ( v2 < 0 )
  {
    v5 = (int *)_errno(v2, v3, v4);
    v6 = (FILE *)stderr;
    v7 = strerror(*v5);
    fprintf(v6, "Unable to open log device '%s' %s\n", "/dev/hwlog_jank", v7);
    goto LABEL_3;
  }
  if ( *(_DWORD *)v1 )
  {
    if ( sub_4F70((int)&v38, 0xAE04u, 1) )
    {
      v9 = "failed to clear the log";
      goto LABEL_80;
    }
  }
  else if ( !*(_DWORD *)(v1 + 4) )
  {
    v35.fd = v2;
    v37 = 0;
    v36 = 1;
    if ( v38 & 0x800 )
      v19 = 5;
    else
      v19 = -1;
    memset(s, 0, 0x1404u);
    if ( (v38 & 3) == 1 )
    {
      v20 = 2;
    }
    else if ( (v38 & 3) == 2 )
    {
      v20 = 6;
    }
    else
    {
      v20 = 4;
    }
    if ( !(v20 & 4) )
    {
      v31 = -1;
      v32 = 1;
      goto LABEL_68;
    }
    while ( 1 )
    {
      v21 = (int *)poll(&v35, 1u, v19);
      if ( v21 == (int *)-1 )
      {
        v21 = (int *)_errno(-1, v22, v23);
        v22 = *v21;
        if ( *v21 != 4 )
          goto LABEL_45;
      }
      else if ( (signed int)v21 > 0 )
      {
        v25 = read(v39, s, 0x1400u);
        if ( v25 > 0 )
        {
          if ( *(unsigned __int16 *)s != v25 - 20 )
          {
            v24 = 22;
LABEL_65:
            v31 = -v24;
            v32 = -v24 < 0;
            if ( !v24 )
            {
LABEL_72:
              v33 = "read: Unexpected EOF!\n";
              v34 = (FILE *)stderr;
              goto LABEL_78;
            }
LABEL_68:
            if ( !v32 || v31 == -11 )
              goto LABEL_3;
            if ( v31 == -5 )
              goto LABEL_72;
            if ( v31 == -22 )
            {
              v33 = "read: unexpected length.\n";
LABEL_77:
              v34 = (FILE *)stderr;
LABEL_78:
              fputs(v33, v34);
LABEL_3:
              if ( v39 >= 0 )
              {
                close(v39);
                v39 = -1;
              }
              v8 = 1;
LABEL_6:
              exit(v8);
            }
            if ( v31 == -28 )
            {
              v33 = "read: all content is read, exit now\n";
              goto LABEL_77;
            }
            v9 = "logcat read failure";
LABEL_80:
            perror(v9);
            goto LABEL_3;
          }
          if ( !v40 || v40 == v46 )
          {
            s[*(unsigned __int16 *)s + 24] = 0;
            if ( j_android_log_processBinaryJlogBuffer((int)s, (int)&v41, &v44, 0x400u) >= 0 )
            {
              v29 = j_android_log_shouldPrintLine(*(_DWORD *)(v1 + 12), v43, v42);
              if ( v29 )
              {
                v29 = j_android_log_printLogLine(*(_DWORD *)(v1 + 12), *(_DWORD *)(v1 + 16), (time_t *)&v41);
                if ( v29 < 0 )
                {
                  perror("output error");
                  v8 = -1;
                  goto LABEL_6;
                }
              }
              **(_DWORD **)(v1 + 24) += v29;
              if ( access(*(const char **)(v1 + 20), 0) )
                (*(void (**)(void))(v1 + 32))();
              v30 = **(_DWORD **)(v1 + 28);
              if ( v30 && v30 <= **(_DWORD **)(v1 + 24) >> 10 )
                (*(void (**)(void))(v1 + 32))();
            }
          }
        }
        else
        {
          if ( !v25 )
          {
            v24 = 5;
            goto LABEL_65;
          }
          v28 = (signed int *)_errno(v25, v26, v27);
          if ( *v28 != 4 )
          {
            v24 = *v28;
            v19 = 5;
            goto LABEL_64;
          }
        }
        v19 = 5;
      }
      else if ( v21 )
      {
LABEL_45:
        v24 = *(_DWORD *)_errno(v21, v22, v23);
LABEL_64:
        if ( v24 )
          goto LABEL_65;
      }
      else
      {
        if ( v38 & 0x800 )
        {
          v24 = 11;
          goto LABEL_65;
        }
        v19 = -1;
      }
    }
  }
  if ( !*(_DWORD *)(v1 + 4) )
    goto LABEL_3;
  v10 = sub_4F70((int)&v38, 0xAE01u, 2);
  if ( v10 >= 0 )
  {
    v11 = sub_4F70((int)&v38, 0xAE02u, 0);
    if ( (v11 & 0x80000000) == 0 )
    {
      v12 = v10;
      v13 = v10;
      v14 = 4;
      do
      {
        if ( v13 < 0x400 )
          break;
        --v14;
        v13 >>= 10;
      }
      while ( v14 );
      v15 = 0;
      do
      {
        if ( v12 < 0x400 )
          break;
        ++v15;
        v12 >>= 10;
      }
      while ( v15 != 4 );
      v16 = v11;
      v17 = 4;
      do
      {
        if ( v16 < 0x400 )
          break;
        --v17;
        v16 >>= 10;
      }
      while ( v17 );
      v18 = 0;
      do
      {
        if ( v11 < 0x400 )
          break;
        ++v18;
        v11 >>= 10;
      }
      while ( v18 != 4 );
      printf("%s: ring buffer is %ld%sb (%ld%sb consumed), max entry is %db, max payload is %db\n", "/dev/hwlog_jank");
      goto LABEL_3;
    }
    v9 = "failed to get the readable log size";
  }
  else
  {
    v9 = "failed to get the log size";
  }
  goto LABEL_80;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 2930: using guessed type int __fastcall _open_2(_DWORD, _DWORD);
// 5138: using guessed type char s[5112];

//----- (00005468) --------------------------------------------------------
unsigned int __fastcall sub_5468(unsigned int a1)
{
  unsigned int result; // r0@3

  if ( a1 == 1000 || a1 == 1007 )
    result = 1;
  else
    result = __clz(a1) >> 5;
  return result;
}

//----- (00005484) --------------------------------------------------------
int __fastcall sub_5484(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // r4@1
  int *v5; // r0@2
  unsigned int v6; // r5@3
  int *v7; // r12@4
  int result; // r0@7
  int v9; // r0@10
  int v10; // r5@10
  unsigned __int8 v11; // cf@12
  int v12; // r9@14
  _BYTE savedregs[32]; // [sp+0h] [bp+0h]@1

  *(_DWORD *)savedregs = a4;
  v4 = getuid();
  if ( !sub_5468(v4) )
  {
    v6 = geteuid();
    if ( sub_5468(v6) )
    {
      v7 = &dword_B05C;
    }
    else
    {
      v6 = getgid();
      if ( sub_5468(v6) )
      {
        v7 = &dword_B05C;
      }
      else
      {
        v6 = getegid();
        if ( !sub_5468(v6) )
        {
          v9 = getgroups(0, 0);
          v10 = v9;
          if ( v9 > 0 )
          {
            getgroups(v9, (__gid_t *)savedregs);
            while ( 1 )
            {
              v11 = __CFADD__(v10--, -1);
              if ( !v11 )
                break;
              v12 = *(_DWORD *)&savedregs[4 * v10];
              if ( sub_5468(*(_DWORD *)&savedregs[4 * v10]) )
              {
                result = v12;
                dword_B05C = v12;
                return result;
              }
            }
          }
          v5 = &dword_B05C;
          goto LABEL_17;
        }
        v7 = &dword_B05C;
      }
    }
    *v7 = v6;
    return v6;
  }
  v5 = &dword_B05C;
LABEL_17:
  *v5 = v4;
  return v4;
}
// B05C: using guessed type int dword_B05C;

//----- (00005548) --------------------------------------------------------
int __fastcall sub_5548(const char *a1, int a2)
{
  int result; // r0@2
  int v3; // r1@2
  int v4; // r2@2

  if ( a2 < 0 )
  {
    result = a2;
  }
  else
  {
    result = strncmp(a1, "success", 7u);
    if ( result )
    {
      *(_DWORD *)_errno(result, v3, v4) = 22;
      result = -1;
    }
  }
  return result;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00005570) --------------------------------------------------------
signed int __fastcall socket_make_sockaddr_un(const char *a1, int a2, void *a3, _DWORD *a4)
{
  int v4; // r7@1
  const char *v5; // r6@1
  void *v6; // r5@1
  _DWORD *v7; // r8@1
  size_t v8; // r4@4
  char *v9; // r0@7
  signed int result; // r0@10

  v4 = a2;
  v5 = a1;
  v6 = a3;
  v7 = a4;
  memset(a3, 0, 0x6Eu);
  if ( v4 == 1 )
  {
    v8 = strlen(v5) + 12;
    if ( v8 <= 0x6B )
    {
      v9 = strcpy((char *)v6 + 2, "/dev/socket/");
      strcat(v9, v5);
      goto LABEL_10;
    }
  }
  else if ( v4 == 2 )
  {
    v8 = strlen(v5);
    if ( v8 <= 0x6B )
    {
      strcpy((char *)v6 + 2, v5);
      goto LABEL_10;
    }
  }
  else if ( !v4 )
  {
    v8 = strlen(v5);
    if ( v8 + 1 <= 0x6C )
    {
      *((_BYTE *)v6 + 2) = 0;
      memcpy((char *)v6 + 3, v5, v8);
LABEL_10:
      result = 0;
      *(_WORD *)v6 = 1;
      *v7 = v8 + 3;
      return result;
    }
  }
  return -1;
}

//----- (00005600) --------------------------------------------------------
signed int __fastcall socket_local_client_connect(int a1, const char *a2, int a3)
{
  int v3; // r5@1
  signed int result; // r0@2
  socklen_t len; // [sp+0h] [bp-88h]@1
  char v6; // [sp+4h] [bp-84h]@1
  int v7; // [sp+74h] [bp-14h]@1

  v3 = a1;
  v7 = _stack_chk_guard;
  if ( j_socket_make_sockaddr_un(a2, a3, &v6, &len) < 0 || connect(v3, (const struct sockaddr *)&v6, len) < 0 )
    result = -1;
  else
    result = v3;
  if ( v7 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (0000564C) --------------------------------------------------------
signed int __fastcall socket_local_client(const char *a1, int a2, int a3)
{
  const char *v3; // r7@1
  int v4; // r6@1
  int v5; // r0@1
  int v6; // r4@1
  bool v7; // nf@2
  signed int result; // r0@2

  v3 = a1;
  v4 = a2;
  v5 = socket(1, a3, 0);
  v6 = v5;
  if ( v5 < 0 )
    goto LABEL_5;
  v7 = j_socket_local_client_connect(v5, v3, v4) < 0;
  result = v6;
  if ( v7 )
  {
    close(v6);
LABEL_5:
    result = -1;
  }
  return result;
}

//----- (00005680) --------------------------------------------------------
signed int __fastcall sub_5680(int a1, int a2, char *a3, size_t a4)
{
  int v4; // r5@1
  const char *v5; // r4@1
  char *v6; // r6@1
  size_t v7; // r9@1
  signed int result; // r0@1
  int v9; // r7@1
  signed int v10; // r3@4
  size_t v11; // r5@7
  int v12; // r1@8
  int v13; // r2@8
  ssize_t v14; // r4@8
  _DWORD *v15; // r0@9
  int v16; // r1@9
  int v17; // r2@9
  size_t v18; // r8@12
  int *v19; // r0@29
  int v20; // r6@29
  int v21; // r0@32
  int v22; // r1@32
  int v23; // r2@32
  int v24; // [sp+0h] [bp-30h]@1
  int v25; // [sp+4h] [bp-2Ch]@1
  char *v26; // [sp+8h] [bp-28h]@1

  v24 = a1;
  v25 = a2;
  v26 = a3;
  v4 = a1;
  v5 = (const char *)a2;
  v6 = a3;
  v7 = a4;
  result = j_socket_local_client("logd", 1, 1);
  v9 = result;
  if ( result >= 0 )
  {
    if ( v5 )
    {
      if ( v4 )
        v10 = *(_DWORD *)(v4 + 12);
      else
        v10 = -1;
      snprintf(v6, v7, v5, v10, v24, v25, v26);
    }
    v11 = strlen(v6) + 1;
    while ( 1 )
    {
      v14 = write(v9, v6, v11);
      if ( v14 != -1 )
        break;
      v15 = (_DWORD *)_errno(0, v12, v13);
      if ( *v15 != 4 )
        goto LABEL_29;
    }
    if ( v14 <= 0 )
      goto LABEL_39;
    v18 = v7;
    while ( 1 )
    {
      while ( 1 )
      {
        v15 = (_DWORD *)read(v9, v6, v18);
        v17 = (int)v15 + 1;
        v14 = (ssize_t)v15;
        if ( v15 != (_DWORD *)-1 )
          break;
        v15 = (_DWORD *)_errno(-1, v16, v17);
        if ( *v15 != 4 )
          goto LABEL_29;
      }
      if ( (signed int)v15 <= 0 || v15 == (_DWORD *)v18 || v7 < 0x1000 )
        break;
      v18 -= (unsigned int)v15;
      v25 = 0;
      v6 = (char *)v15 + (_DWORD)v6;
      v24 = v9;
      LOWORD(v25) = 1;
      while ( 1 )
      {
        v15 = (_DWORD *)poll((struct pollfd *)&v24, 1u, 20);
        v16 = (int)v15 + 1;
        v14 = (ssize_t)v15;
        if ( v15 != (_DWORD *)-1 )
          break;
        v15 = (_DWORD *)_errno(-1, v16, v17);
        v16 = *v15;
        if ( *v15 != 4 )
          goto LABEL_29;
      }
      if ( (signed int)v15 <= 0 )
        break;
      v15 = (_DWORD *)HIWORD(v25);
      v14 = BYTE2(v25) & 1;
      if ( !(BYTE2(v25) & 1) )
        goto LABEL_27;
    }
    if ( v14 < 0 )
      goto LABEL_28;
LABEL_27:
    v17 = v14 - v18;
    v14 = v14 - v18 + v7;
LABEL_28:
    if ( v14 != -1 )
    {
LABEL_39:
      v20 = 0;
      goto LABEL_32;
    }
LABEL_29:
    v19 = (int *)_errno(v15, v16, v17);
    v20 = *v19;
    if ( *v19 )
      v20 = *v19;
    v14 = -1;
LABEL_32:
    v21 = close(v9);
    if ( v20 )
      *(_DWORD *)_errno(v21, v22, v23) = v20;
    result = v14;
  }
  return result;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00005790) --------------------------------------------------------
char *__fastcall android_log_id_to_name(unsigned int a1)
{
  if ( a1 > 6 )
    a1 = 0;
  return off_AC88[a1];
}
// AC88: using guessed type char *off_AC88[6];

//----- (000057A4) --------------------------------------------------------
signed int __fastcall android_name_to_log_id(const char *a1)
{
  const char *v1; // r5@1
  char *v2; // r0@2
  signed int v3; // r4@4
  const char *v4; // r1@5
  signed int result; // r0@7

  v1 = a1;
  if ( a1 )
  {
    v2 = strrchr(a1, 47);
    if ( v2 )
      v1 = v2 + 1;
    v3 = 0;
    while ( 1 )
    {
      v4 = off_AC88[v3];
      if ( v4 )
      {
        if ( !strcmp(v1, v4) )
          break;
      }
      if ( ++v3 == 7 )
        goto LABEL_9;
    }
    result = v3;
  }
  else
  {
LABEL_9:
    result = -1;
  }
  return result;
}
// AC88: using guessed type char *off_AC88[6];

//----- (000057DC) --------------------------------------------------------
int __fastcall android_logger_get_id(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (000057E0) --------------------------------------------------------
int __fastcall android_logger_clear(int a1)
{
  int v1; // r1@1
  int v2; // r4@1
  int v3; // r0@2
  int v4; // r1@4
  int v5; // r2@4
  int result; // r0@5
  int v7; // r0@7
  char v8; // [sp+4h] [bp-214h]@7
  int v9; // [sp+204h] [bp-14h]@1

  v1 = *(_DWORD *)(a1 + 8);
  v2 = *(_DWORD *)(v1 + 8);
  v9 = _stack_chk_guard;
  if ( v2 >= 0 )
  {
    v7 = sub_5680(a1, (int)"clear %d", &v8, 0x200u);
    result = sub_5548(&v8, v7);
  }
  else
  {
    v3 = dword_B05C;
    if ( dword_B05C == -1 )
      v3 = sub_5484(dword_B05C, v1, _stack_chk_guard, dword_B05C + 1);
    if ( sub_5468(v3) )
    {
      result = unlink("/sys/fs/pstore/pmsg-ramoops-0");
    }
    else
    {
      *(_DWORD *)_errno(0, v4, v5) = 1;
      result = -1;
    }
  }
  if ( v9 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// B05C: using guessed type int dword_B05C;

//----- (00005860) --------------------------------------------------------
signed int __fastcall android_logger_get_log_size(int a1)
{
  signed int result; // r0@1
  unsigned __int8 v2; // [sp+4h] [bp-214h]@1
  int v3; // [sp+204h] [bp-14h]@1

  v3 = _stack_chk_guard;
  result = sub_5680(a1, (int)"getLogSize %d", (char *)&v2, 0x200u);
  if ( result >= 0 )
  {
    if ( (unsigned int)v2 - 48 > 9 )
      result = -1;
    else
      result = atol((const char *)&v2);
  }
  if ( v3 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (000058B4) --------------------------------------------------------
int __fastcall android_logger_set_log_size(int a1, int a2)
{
  signed int v2; // r3@2
  int v3; // r0@4
  int result; // r0@4
  char s; // [sp+Ch] [bp-214h]@4
  int v6; // [sp+20Ch] [bp-14h]@1

  v6 = _stack_chk_guard;
  if ( a1 )
    v2 = *(_DWORD *)(a1 + 12);
  else
    v2 = -1;
  snprintf(&s, 0x200u, "setLogSize %d %lu", v2, a2);
  v3 = sub_5680(0, 0, &s, 0x200u);
  result = sub_5548(&s, v3);
  if ( v6 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00005914) --------------------------------------------------------
signed int __fastcall android_logger_get_log_readable_size(int a1)
{
  signed int result; // r0@1
  unsigned __int8 v2; // [sp+4h] [bp-214h]@1
  int v3; // [sp+204h] [bp-14h]@1

  v3 = _stack_chk_guard;
  result = sub_5680(a1, (int)"getLogSizeUsed %d", (char *)&v2, 0x200u);
  if ( result >= 0 )
  {
    if ( (unsigned int)v2 - 48 > 9 )
      result = -1;
    else
      result = atol((const char *)&v2);
  }
  if ( v3 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00005968) --------------------------------------------------------
signed int android_logger_get_log_version()
{
  return 3;
}

//----- (0000596C) --------------------------------------------------------
signed int __fastcall android_logger_get_statistics(int *a1, char *a2, size_t a3)
{
  size_t v3; // r5@1
  int *v4; // r9@1
  char *v5; // r8@1
  unsigned int v6; // r0@1
  int v7; // r6@1
  size_t v8; // r7@3
  char *v9; // r4@3
  unsigned int v10; // r0@5

  v3 = a3;
  v4 = a1;
  v5 = a2;
  v6 = snprintf(a2, a3, "getStatistics");
  v7 = *v4;
  if ( v6 >= v3 )
    v6 = v3;
  v8 = v3 - v6;
  v9 = &v5[v6];
  while ( (int *)v7 != v4 )
  {
    v10 = snprintf(v9, v8, " %d", *(_DWORD *)(v7 + 12));
    v7 = *(_DWORD *)v7;
    if ( v10 >= v8 )
      v10 = v8;
    v8 -= v10;
    v9 += v10;
  }
  return sub_5680(0, 0, v5, v3);
}

//----- (000059D0) --------------------------------------------------------
signed int __fastcall android_logger_get_prune_list(int a1, char *a2, size_t a3)
{
  return sub_5680(0, (int)"getPruneList", a2, a3);
}

//----- (000059EC) --------------------------------------------------------
signed int __fastcall android_logger_set_prune_list(int a1, int a2, size_t a3)
{
  char *v3; // lr@1
  size_t v4; // r8@1
  int v5; // r6@1
  const char *v6; // r4@1
  int v7; // r0@2
  int v8; // r1@2
  int v9; // r12@2
  __int16 v10; // r1@3
  char *v11; // r1@4
  int v12; // r2@4
  int v13; // r0@5
  int v14; // r12@5
  signed int result; // r0@6
  char v16; // [sp+4h] [bp-2Ch]@1
  char v17; // [sp+Ch] [bp-24h]@5
  int v18; // [sp+14h] [bp-1Ch]@1

  v3 = &v16;
  v4 = a3;
  v5 = a2;
  v6 = "setPruneList ";
  v18 = _stack_chk_guard;
  do
  {
    v7 = *(_DWORD *)v6;
    v6 += 8;
    v8 = *(_DWORD *)&v6[0xFFFFFFFC];
    *(_DWORD *)v3 = v7;
    *((_DWORD *)v3 + 1) = v8;
    v9 = (int)(v3 + 8);
    v3 += 8;
  }
  while ( v6 != "List " );
  v10 = *((_WORD *)v6 + 2);
  *(_DWORD *)v9 = *(_DWORD *)v6;
  *(_WORD *)(v9 + 4) = v10;
  if ( strlen((const char *)v5) <= a3 - 13 )
  {
    memmove((void *)(v5 + 13), (const void *)v5, v4 - 13);
    v11 = &v16;
    v12 = v5;
    *(_BYTE *)(v5 + v4 - 1) = 0;
    do
    {
      v12 += 8;
      v13 = *(_DWORD *)v11;
      v14 = (int)(v11 + 8);
      *(_DWORD *)(v12 - 4) = *((_DWORD *)v11 + 1);
      v11 = (char *)v14;
      *(_DWORD *)(v12 - 8) = v13;
    }
    while ( (char *)v14 != &v17 );
    *(_DWORD *)v12 = *(_DWORD *)v14;
    *(_BYTE *)(v12 + 4) = *(_BYTE *)(v14 + 4);
    result = sub_5680(0, 0, (char *)v5, v4);
    if ( v18 == _stack_chk_guard )
      return sub_5548((const char *)v5, result);
LABEL_9:
    _stack_chk_fail(result);
  }
  result = -12;
  if ( v18 != _stack_chk_guard )
    goto LABEL_9;
  return result;
}
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00005AB8) --------------------------------------------------------
_DWORD *__fastcall android_logger_list_alloc(int a1, int a2, int a3)
{
  int v3; // r6@1
  int v4; // r5@1
  int v5; // r4@1
  _DWORD *result; // r0@1

  v3 = a1;
  v4 = a2;
  v5 = a3;
  result = calloc(1u, 0x20u);
  if ( result )
  {
    *result = result;
    result[1] = result;
    result[2] = v3;
    result[4] = 0;
    result[5] = 0;
    result[3] = v4;
    result[6] = v5;
    result[7] = -1;
  }
  return result;
}

//----- (00005AE2) --------------------------------------------------------
_DWORD *__fastcall android_logger_list_alloc_time(int a1, __int64 a2, int a3)
{
  int v3; // r4@1
  int v4; // r6@1
  _DWORD *result; // r0@1
  __int64 v6; // [sp+0h] [bp-18h]@1

  v3 = a1;
  v4 = a3;
  v6 = a2;
  result = calloc(1u, 0x20u);
  if ( result )
  {
    *result = result;
    result[1] = result;
    result[2] = v3;
    *((_QWORD *)result + 2) = v6;
    result[6] = v4;
    result[3] = 0;
    result[7] = -1;
  }
  return result;
}

//----- (00005B1C) --------------------------------------------------------
_DWORD *__fastcall android_logger_open(_DWORD *result, unsigned int a2)
{
  unsigned int v2; // r5@1
  _DWORD *v3; // r4@1
  _DWORD *v4; // r3@8

  v2 = a2;
  v3 = result;
  if ( result )
  {
    if ( a2 > 6 )
    {
      result = 0;
    }
    else
    {
      for ( result = (_DWORD *)*result; result != v3; result = (_DWORD *)*result )
      {
        if ( result[3] == a2 )
          return result;
      }
      result = calloc(1u, 0x10u);
      if ( result )
      {
        v4 = (_DWORD *)v3[1];
        result[3] = v2;
        *result = v3;
        result[1] = v4;
        *v4 = result;
        v3[1] = result;
        result[2] = v3;
      }
    }
  }
  return result;
}

//----- (00005B58) --------------------------------------------------------
_DWORD *__fastcall android_logger_list_read(int a1, void *a2)
{
  void *v2; // r6@1
  int v3; // r4@1
  int v4; // r0@2
  _DWORD *result; // r0@4
  int v6; // r1@4
  int v7; // r2@4
  char *v8; // r12@19
  char v9; // lr@20
  int v10; // r7@23
  int v11; // r0@23
  unsigned int v12; // r3@27
  int v13; // r1@32
  int v14; // r7@34
  int v15; // r5@43
  __off_t v16; // r0@45
  __off_t v17; // r7@45
  _DWORD *v18; // r0@51
  signed int v19; // r0@58
  int v20; // r1@58
  int v21; // r2@58
  int v22; // r5@58
  const char *v23; // r1@64
  char *v24; // r7@66
  char *v25; // r0@66
  char *v26; // r7@66
  char *v27; // r8@66
  int v28; // r10@66
  signed int v29; // r3@66
  int v30; // r0@68
  int v31; // r0@72
  int v32; // r0@77
  int v33; // r0@81
  unsigned int v34; // r11@84
  ssize_t v35; // r9@86
  int v36; // r1@86
  int v37; // r2@86
  signed int v38; // r7@86
  int v39; // r1@102
  int v40; // r2@102
  int i; // r1@111
  char *v42; // [sp+14h] [bp-154h]@20
  char s; // [sp+18h] [bp-150h]@56
  sigset_t set; // [sp+1Ch] [bp-14Ch]@7
  int v45; // [sp+13Ch] [bp-2Ch]@1

  v2 = a2;
  v3 = a1;
  v45 = _stack_chk_guard;
  if ( !a1 )
  {
    result = (_DWORD *)-22;
    goto LABEL_117;
  }
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 < 0 )
  {
    memset(a2, 0, 0x1404u);
    if ( *(_DWORD *)(v3 + 28) >= 0 )
      goto LABEL_6;
    result = (_DWORD *)open("/sys/fs/pstore/pmsg-ramoops-0", 0);
    if ( (signed int)result >= 0 )
    {
      *(_DWORD *)(v3 + 28) = result;
      byte_B080 = 0;
      while ( 1 )
      {
        while ( 1 )
        {
LABEL_6:
          if ( (unsigned __int8)byte_B080 <= 0x11u )
          {
            while ( 1 )
            {
              result = (_DWORD *)read(
                                   *(_DWORD *)(v3 + 28),
                                   (char *)&set.__val[3] + (unsigned __int8)byte_B080,
                                   18 - (unsigned __int8)byte_B080);
              v6 = (int)result + 1;
              if ( result != (_DWORD *)-1 )
                break;
              result = (_DWORD *)_errno(-1, v6, v7);
              v7 = *result;
              if ( *result != 4 )
                goto LABEL_51;
            }
            if ( (signed int)result < 0 )
              goto LABEL_51;
            byte_B080 += (char)result;
          }
          if ( byte_B080 != 18 )
          {
            if ( byte_B080 )
              goto LABEL_14;
            result = (_DWORD *)-11;
            goto LABEL_117;
          }
          if ( LOBYTE(set.__val[3]) == 108
            && (unsigned __int16)(*(_WORD *)((char *)&set.__val[3] + 1) - 19) <= 0xFEBu
            && BYTE3(set.__val[4]) <= 6u
            && *(unsigned __int32 *)((char *)&set.__val[6] + 2) <= 0x3B9AC9FF )
          {
            break;
          }
          v8 = (char *)&set.__val[3] + 1;
          do
          {
            v9 = byte_B080;
            v42 = v8;
            _memmove_chk(&set.__val[3], v8, (unsigned __int8)--byte_B080, 18);
            if ( v9 == 1 )
              break;
            v8 = v42;
          }
          while ( LOBYTE(set.__val[3]) != 108 );
        }
        v10 = *(_DWORD *)v3;
        v11 = 0;
        byte_B080 = 0;
        while ( 1 )
        {
          if ( v10 == v3 )
            goto LABEL_45;
          if ( BYTE3(set.__val[4]) == *(_DWORD *)(v10 + 12) )
            break;
          v10 = *(_DWORD *)v10;
        }
        if ( (v12 = *(_DWORD *)(v3 + 16)) == 0 && !*(_DWORD *)(v3 + 20)
          || (v11 = *(unsigned __int32 *)((char *)&set.__val[5] + 2),
              v12 <= *(unsigned __int32 *)((char *)&set.__val[5] + 2))
          && (v12 != *(unsigned __int32 *)((char *)&set.__val[5] + 2)
           || *(_DWORD *)(v3 + 20) <= *(unsigned __int32 *)((char *)&set.__val[6] + 2)) )
        {
          v13 = *(_DWORD *)(v3 + 24);
          if ( !v13
            || (v12 = *(unsigned __int16 *)((char *)&set.__val[4] + 1),
                v13 == *(unsigned __int16 *)((char *)&set.__val[4] + 1)) )
          {
            v14 = dword_B05C;
            if ( dword_B05C == -1 )
              v14 = sub_5484(v11, v13, dword_B05C + 1, v12);
            if ( sub_5468(v14) || v14 == *(unsigned __int16 *)((char *)&set.__val[3] + 3) )
              break;
          }
        }
LABEL_45:
        while ( 1 )
        {
          v16 = lseek(*(_DWORD *)(v3 + 28), 0, 1);
          v17 = v16;
          result = (_DWORD *)(v16 + 1);
          if ( result )
            break;
          result = *(_DWORD **)_errno(0, v6, v7);
          if ( result != (_DWORD *)4 )
            goto LABEL_51;
        }
        if ( v17 < 0 )
          goto LABEL_51;
        while ( 1 )
        {
          result = (_DWORD *)lseek(*(_DWORD *)(v3 + 28), *(unsigned __int16 *)((char *)&set.__val[3] + 1) - 18, 1);
          v6 = (int)result + 1;
          if ( result != (_DWORD *)-1 )
            break;
          result = (_DWORD *)_errno(-1, v6, v7);
          v7 = *result;
          if ( *result != 4 )
            goto LABEL_51;
        }
        if ( (signed int)result < 0 )
          goto LABEL_51;
        if ( (_DWORD *)((char *)result - v17) != (_DWORD *)(*(unsigned __int16 *)((char *)&set.__val[3] + 1) - 18) )
          goto LABEL_14;
      }
      while ( 1 )
      {
        result = (_DWORD *)read(
                             *(_DWORD *)(v3 + 28),
                             (char *)v2 + 24,
                             *(unsigned __int16 *)((char *)&set.__val[3] + 1) - 18);
        if ( result != (_DWORD *)-1 )
          break;
        result = *(_DWORD **)_errno(-1, v6, v7);
        if ( result != (_DWORD *)4 )
          goto LABEL_51;
      }
      if ( (signed int)result >= 0 )
      {
        if ( result == (_DWORD *)(*(unsigned __int16 *)((char *)&set.__val[3] + 1) - 18) )
        {
          *(_WORD *)v2 = (_WORD)result;
          *((_WORD *)v2 + 1) = 24;
          *((_DWORD *)v2 + 1) = *(unsigned __int16 *)((char *)&set.__val[4] + 1);
          *((_DWORD *)v2 + 2) = LOWORD(set.__val[5]);
          *((_DWORD *)v2 + 3) = *(unsigned __int32 *)((char *)&set.__val[5] + 2);
          v15 = BYTE3(set.__val[4]);
          *((_DWORD *)v2 + 4) = *(unsigned __int32 *)((char *)&set.__val[6] + 2);
          *((_DWORD *)v2 + 5) = v15;
          goto LABEL_117;
        }
LABEL_14:
        result = (_DWORD *)-5;
        goto LABEL_117;
      }
    }
LABEL_51:
    v18 = (_DWORD *)_errno(result, v6, v7);
    goto LABEL_62;
  }
  if ( v4 & 0x800 )
  {
    memset(&s, 0, 0x10u);
    *(_DWORD *)&s = nullsub_1;
    sigemptyset(&set);
  }
  if ( *(_DWORD *)(v3 + 28) >= 0 )
  {
    v34 = 0;
  }
  else
  {
    v19 = j_socket_local_client("logdr", 1, 5);
    v22 = v19;
    if ( v19 < 0 )
    {
      if ( v19 == -1 )
      {
        v18 = (_DWORD *)_errno(-1, v20, v21);
        if ( *v18 )
        {
LABEL_62:
          result = (_DWORD *)-*v18;
          goto LABEL_117;
        }
LABEL_61:
        result = (_DWORD *)-1;
        goto LABEL_117;
      }
      goto LABEL_116;
    }
    if ( *(_DWORD *)(v3 + 8) & 0x800 )
      v23 = "dumpAndClose";
    else
      v23 = "stream";
    strcpy((char *)&set.__val[8], v23);
    v24 = (char *)&set.__val[8] + _strlen_chk(&set.__val[8], 256);
    v25 = v24;
    v26 = v24 + 5;
    v27 = (char *)((char *)&set.__val[8] - v26 + 256);
    strcpy(v25, " lids");
    v28 = *(_DWORD *)v3;
    v29 = 61;
    while ( v28 != v3 )
    {
      v30 = snprintf(v26, (size_t)v27, "%c%u", v29, *(_DWORD *)(v28 + 12));
      v28 = *(_DWORD *)v28;
      v29 = 44;
      if ( v30 >= (signed int)v27 )
        v30 = (int)v27;
      v27 -= v30;
      v26 += v30;
    }
    if ( *(_DWORD *)(v3 + 12) )
    {
      v31 = snprintf(v26, (size_t)v27, " tail=%u");
      if ( v31 >= (signed int)v27 )
        v31 = (int)v27;
      v27 -= v31;
      v26 += v31;
    }
    if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 20) )
    {
      v32 = snprintf(v26, (size_t)v27, " start=%u.%09u");
      if ( v32 >= (signed int)v27 )
        v32 = (int)v27;
      v27 -= v32;
      v26 += v32;
    }
    if ( *(_DWORD *)(v3 + 24) )
    {
      v33 = snprintf(v26, (size_t)v27, " pid=%u");
      if ( v33 > (signed int)v27 )
        v26 = &v27[(_DWORD)v26];
      else
        v26 += v33;
    }
    v34 = *(_DWORD *)(v3 + 8) & 0x800;
    if ( v34 )
    {
      sigaction(14, (const struct sigaction *)&s, (struct sigaction *)&set.__val[3]);
      v34 = alarm(0x1Eu);
    }
    v35 = write(v22, &set.__val[8], v26 - (char *)&set.__val[8]);
    v38 = *(_DWORD *)_errno(v35, v36, v37);
    if ( *(_DWORD *)(v3 + 8) & 0x800 )
    {
      if ( v38 == 4 )
        v38 = 110;
      alarm(v34);
      sigaction(14, (const struct sigaction *)&set.__val[3], 0);
    }
    if ( v35 <= 0 )
    {
      close(v22);
      if ( v35 != -1 )
      {
        if ( v35 )
          result = (_DWORD *)v35;
        else
          result = (_DWORD *)-5;
        goto LABEL_117;
      }
      if ( !v38 )
        goto LABEL_61;
      goto LABEL_110;
    }
    *(_DWORD *)(v3 + 28) = v22;
  }
  while ( 1 )
  {
    memset(v2, 0, 0x1404u);
    if ( *(_DWORD *)(v3 + 8) & 0x800 )
    {
      sigaction(14, (const struct sigaction *)&s, (struct sigaction *)&set.__val[3]);
      v34 = alarm(0x1Eu);
    }
    v22 = recvfrom(*(_DWORD *)(v3 + 28), v2, 0x1400u, 0, 0, 0);
    v38 = *(_DWORD *)_errno(v22, v39, v40);
    if ( *(_DWORD *)(v3 + 8) & 0x800 )
    {
      if ( !v22 || v38 == 4 )
      {
        v38 = 11;
        v22 = -1;
      }
      alarm(v34);
      sigaction(14, (const struct sigaction *)&set.__val[3], 0);
    }
    if ( v22 <= 0 )
      break;
    for ( i = *(_DWORD *)v3; i != v3; i = *(_DWORD *)i )
    {
      if ( *((_DWORD *)v2 + 5) == *(_DWORD *)(i + 12) )
        goto LABEL_116;
    }
  }
  if ( v22 == -1 && v38 )
  {
LABEL_110:
    result = (_DWORD *)-v38;
    goto LABEL_117;
  }
LABEL_116:
  result = (_DWORD *)v22;
LABEL_117:
  if ( v45 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 2660: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 26A8: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 278C: using guessed type int __fastcall _strlen_chk(_DWORD, _DWORD);
// 2A38: using guessed type int __fastcall _memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 5482: using guessed type int nullsub_1();
// B05C: using guessed type int dword_B05C;
// B080: using guessed type char byte_B080;

//----- (00006000) --------------------------------------------------------
void __fastcall android_logger_list_free(int a1)
{
  int v1; // r4@1
  _DWORD *v2; // r0@6
  int v3; // r0@7

  v1 = a1;
  if ( a1 )
  {
LABEL_6:
    v2 = *(_DWORD **)v1;
    while ( (_DWORD *)v1 != v2 )
    {
      if ( v2 )
      {
        *(_DWORD *)(*v2 + 4) = v2[1];
        *(_DWORD *)(*(_QWORD *)v2 >> 32) = *(_QWORD *)v2;
        free(v2);
        goto LABEL_6;
      }
    }
    v3 = *(_DWORD *)(v1 + 28);
    if ( v3 >= 0 )
      close(v3);
    j_j_free((void *)v1);
  }
}

//----- (0000603A) --------------------------------------------------------
_DWORD *__fastcall android_logger_list_open(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // r5@1
  _DWORD *result; // r0@1
  int v6; // r4@1
  _DWORD *v7; // r5@2

  v4 = a1;
  result = j_android_logger_list_alloc(a2, a3, a4);
  v6 = (int)result;
  if ( result )
  {
    v7 = j_android_logger_open(result, v4);
    result = (_DWORD *)v6;
    if ( !v7 )
    {
      j_android_logger_list_free(v6);
      result = 0;
    }
  }
  return result;
}

//----- (00006064) --------------------------------------------------------
int *sub_6064()
{
  void *v0; // r0@1
  void *v1; // r5@1
  const char *v2; // r1@2
  const char *v3; // r2@2
  void *v4; // r0@3
  int *result; // r0@8

  v0 = dlopen("libpowergenie_native3.so", 1);
  v1 = v0;
  if ( v0 )
  {
    dword_B088 = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))dlsym(v0, "__android_logPower_buf_write");
    v4 = dlsym(v1, "__android_logPower_print");
    dword_B084 = (int (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v4;
    if ( dword_B088 && v4 )
    {
      j___android_log_print(4, 0, "power log dlsym ok");
      goto LABEL_8;
    }
    dlerror();
    v2 = 0;
    v3 = "power log dlsym err:%s";
  }
  else
  {
    dlerror();
    v2 = (const char *)v1;
    v3 = "power log dlopen err:%s";
  }
  j___android_log_print(6, v2, v3);
LABEL_8:
  result = &dword_B08C;
  dword_B08C = 1;
  return result;
}
// B084: using guessed type int (__fastcall *dword_B084)(_DWORD, _DWORD, _DWORD, _DWORD);
// B088: using guessed type int (__fastcall *dword_B088)(_DWORD, _DWORD, _DWORD);
// B08C: using guessed type int dword_B08C;

//----- (000060F8) --------------------------------------------------------
int __fastcall _android_logPower_buf_write(int a1, int a2, int a3)
{
  int v3; // r7@1
  int v4; // r6@1
  int v5; // r5@1
  int (__fastcall *v6)(_DWORD, _DWORD, _DWORD); // r4@3
  int result; // r0@4

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !dword_B08C )
    sub_6064();
  v6 = dword_B088;
  if ( dword_B088 )
  {
    result = dword_B088(v3, v4, v5);
  }
  else
  {
    j___android_log_print(6, (const char *)dword_B088, "logPower_buf_write not support");
    result = (int)v6;
  }
  return result;
}
// B088: invalid function type has been ignored
// B088: using guessed type int (__fastcall *dword_B088)(_DWORD, _DWORD, _DWORD);
// B08C: using guessed type int dword_B08C;

//----- (00006144) --------------------------------------------------------
int __fastcall _android_logPower_print(int a1, int a2, int a3, int a4)
{
  int v4; // r5@1
  int v5; // r8@1
  int v6; // r7@1
  int v7; // r6@1
  int (__fastcall *v8)(_DWORD, _DWORD, _DWORD, _DWORD); // r4@3
  int result; // r0@4

  v4 = a4;
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if ( !dword_B08C )
    sub_6064();
  v8 = dword_B084;
  if ( dword_B084 )
  {
    result = dword_B084(v5, v6, v7, v4);
  }
  else
  {
    j___android_log_print(6, (const char *)dword_B084, "logPower_print not support");
    result = (int)v8;
  }
  return result;
}
// B084: invalid function type has been ignored
// B084: using guessed type int (__fastcall *dword_B084)(_DWORD, _DWORD, _DWORD, _DWORD);
// B08C: using guessed type int dword_B08C;

//----- (0000619C) --------------------------------------------------------
signed __int64 __fastcall systemTime(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-10h]@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v6 = a3;
  v5 = 0;
  v4 = 0;
  clock_gettime(dword_9058[a1], (struct timespec *)&v4);
  return 1000000000LL * v4 + v5;
}

//----- (000061D0) --------------------------------------------------------
int __fastcall toMillisecondTimeoutDelay(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // r0@2
  unsigned __int64 v3; // r0@3

  if ( SHIDWORD(a1) >= HIDWORD(a2) + ((unsigned int)a1 < (unsigned int)a2) )
  {
    LODWORD(v3) = 0;
  }
  else
  {
    v2 = a2 - a1;
    if ( __PAIR__(*(unsigned int *)((char *)&loc_621A + 2), loc_6218) >= v2 )
      v3 = (v2 + 999999) / 0xF4240;
    else
      LODWORD(v3) = -1;
  }
  return v3;
}

//----- (00006220) --------------------------------------------------------
signed int __fastcall sub_6220(int a1, int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // r5@1
  unsigned int v5; // r7@1
  int v6; // r10@1
  int v7; // r4@1
  int v8; // r11@2
  unsigned int v9; // r8@7
  int v10; // r9@7
  int v11; // r0@8
  int v12; // r2@9
  int v13; // r1@10
  signed int result; // r0@10
  int v15; // r3@19
  int v16; // r2@19
  int v17; // r0@19
  int v18; // r1@19
  int v19; // r2@37
  int v20; // r0@39
  int v21; // r1@39
  int v22; // r3@39
  unsigned int v23; // r1@40
  unsigned int v24; // r0@40
  int v25; // r1@42
  int v26; // r6@45
  char v27; // r1@45
  int v29; // r0@50
  unsigned int v35; // r0@51
  int v36; // [sp+4h] [bp-34h]@58
  int v37; // [sp+8h] [bp-30h]@6
  int v38; // [sp+Ch] [bp-2Ch]@22
  int v39; // [sp+10h] [bp-28h]@8

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a3 >= a4 )
    goto LABEL_58;
  v8 = 0;
  do
  {
    v9 = v5 + 1;
    v10 = *(_BYTE *)(v6 + (v5 ^ 3));
    if ( !(v10 & 0x80) )
    {
      sub_6A9C(v7, 13, &v39);
      v11 = 4 * v10;
      if ( v10 & 0x40 )
        v12 = -4 - (v11 & 0xFC) + v39;
      else
        v12 = v11 + v39 + 4;
      v39 = v12;
LABEL_23:
      sub_6ACC(v7, 13, v12);
      ++v5;
      continue;
    }
    v13 = v10 & 0xF0;
    result = 9;
    if ( v13 > 159 )
    {
      if ( v13 > 191 )
      {
        if ( v13 == 192 )
        {
          switch ( v10 )
          {
            case 199:
              if ( !*(_BYTE *)(v6 + (v9 ^ 3)) || (unsigned int)*(_BYTE *)(v6 + (v9 ^ 3)) >= 0x10 )
                return 9;
              goto LABEL_55;
            case 192:
            case 193:
            case 194:
            case 195:
            case 196:
            case 197:
              v18 = 3;
              v16 = ((v10 & 7) + 1) | 0xA0000;
              v17 = v7;
              goto LABEL_33;
            case 200:
            case 201:
              v23 = *(_BYTE *)(v6 + (v9 ^ 3));
              v24 = v23 >> 4;
              if ( v10 == 200 )
                v24 = (v23 >> 4) | 0x10;
              v25 = v23 & 0xF;
              if ( (signed int)(v24 + v25) > 31 )
                return 9;
              v19 = (v25 + 1) | (v24 << 16);
              v20 = v7;
              v21 = 1;
              goto LABEL_53;
            case 198:
              v35 = *(_BYTE *)(v6 + (v9 ^ 3));
              if ( (signed int)((v35 & 0xF) + (v35 >> 4)) > 15 )
                return 9;
              v19 = ((v35 & 0xF) + 1) | (v35 >> 4 << 16);
              v20 = v7;
              v21 = 3;
LABEL_53:
              v22 = 5;
LABEL_54:
              sub_6608(v20, v21, v19, v22);
              goto LABEL_55;
            default:
              return 9;
          }
          return 9;
        }
        if ( v13 != 208 )
          return result;
        if ( v10 & 8 )
          return 9;
        v18 = 1;
        v16 = ((v10 & 7) + 1) | 0x80000;
        v17 = v7;
LABEL_33:
        v15 = 5;
      }
      else
      {
        if ( v13 != 160 )
        {
          if ( v13 != 176 )
            return result;
          result = 9;
          switch ( v10 )
          {
            case 177:
              if ( v9 >= v4 )
                return 9;
              v19 = *(_BYTE *)(v6 + (v9 ^ 3));
              result = 9;
              if ( !*(_BYTE *)(v6 + (v9 ^ 3)) || v19 & 0xF0 )
                return result;
              v20 = v7;
              v21 = 0;
              v22 = 0;
              goto LABEL_54;
            case 178:
              if ( v9 >= v4 )
                return 9;
              v5 += 2;
              v26 = 0;
              v27 = 0;
              break;
            case 179:
              v22 = 1;
              v29 = *(_BYTE *)(v6 + (v9 ^ 3));
              _R1 = v29 << 12;
              __asm { UXTB16.W        R1, R1 }
              v19 = ((v29 & 0xF) + 1) | _R1;
              v20 = v7;
              v21 = 1;
              goto LABEL_54;
            case 176:
              goto LABEL_57;
            case 180:
            case 181:
            case 182:
            case 183:
              return result;
            default:
              v18 = 1;
              v15 = 1;
              v16 = ((v10 & 7) + 1) | 0x80000;
              v17 = v7;
              goto LABEL_34;
          }
          while ( 1 )
          {
            v26 |= (*(_BYTE *)(v6 + ((v5 - 1) ^ 3)) & 0x7F) << v27;
            if ( !(*(_BYTE *)(v6 + ((v5 - 1) ^ 3)) & 0x80) )
              break;
            _CF = v5 >= v4;
            v27 += 7;
            result = 9;
            ++v5;
            if ( _CF )
              return result;
          }
          sub_6A9C(v7, 13, &v37);
          v37 += 4 * v26 + 516;
          sub_6ACC(v7, 13, v37);
          continue;
        }
        v15 = 0;
        v16 = ((16 << ((*(_BYTE *)(v6 + (v5 ^ 3)) & 7) + 1)) - 16) | (*(_BYTE *)(v6 + (v5 ^ 3)) << 11) & 0x4000;
        v17 = v7;
        v18 = 0;
      }
LABEL_34:
      sub_6608(v17, v18, v16, v15);
      ++v5;
      continue;
    }
    if ( v13 != 128 )
    {
      if ( v13 != 144 )
        return result;
      if ( (v10 & 0xF | 2) == 15 )
        return 9;
      sub_6A9C(v7, v10 & 0xF, &v38);
      v12 = v38;
      goto LABEL_23;
    }
    if ( v9 >= v4 || !((unsigned __int16)((_WORD)v10 << 12) | 16 * *(_BYTE *)(v6 + ((v5 + 1) ^ 3))) )
      return 9;
    sub_6608(v7, 0, (unsigned __int16)((_WORD)v10 << 12) | 16 * *(_BYTE *)(v6 + (v9 ^ 3)), 0);
    v8 |= (((_WORD)v10 << 12) & 0x8000u) >> 15;
LABEL_55:
    v5 += 2;
  }
  while ( v5 < v4 );
LABEL_57:
  if ( v8 & 1 )
    return 8;
LABEL_58:
  sub_6A9C(v7, 14, &v36);
  sub_6ACC(v7, 15, v36);
  return 8;
}

//----- (00006564) --------------------------------------------------------
signed int __fastcall sub_6564(int a1, int a2, unsigned int a3, int a4, int *a5)
{
  int v5; // r5@1
  int v6; // r4@1
  signed int result; // r0@2
  int v8; // r2@4
  int v9; // r0@4
  int v10; // r1@4
  __int64 v11; // r2@10
  int v12; // r1@10

  v5 = a3;
  v6 = a1;
  switch ( a2 )
  {
    case 0:
      result = 2;
      if ( a3 > 0xF || a4 )
        return result;
      v8 = *a5;
      v9 = v6;
      v10 = v5;
      goto LABEL_14;
    case 1:
      if ( a4 == 5 )
      {
        if ( a3 <= 0x1F )
          goto LABEL_21;
        return 2;
      }
      if ( a4 != 1 || a3 > 0xF )
        return 2;
      sub_6BB8(a1);
LABEL_21:
      v11 = *(_QWORD *)a5;
      v12 = v5 + 256;
LABEL_22:
      result = sub_6B40(v6, v12, v11, SHIDWORD(v11));
LABEL_23:
      if ( result )
        result = 2;
      return result;
    case 3:
      result = 2;
      if ( a3 > 0x1F || a4 != 5 )
        return result;
      v11 = *(_QWORD *)a5;
      v12 = v5 + 112;
      goto LABEL_22;
    case 4:
      result = 2;
      if ( a3 > 3 || a4 )
        return result;
      v8 = *a5;
      v10 = v5 + 192;
      v9 = v6;
LABEL_14:
      result = sub_6ACC(v9, v10, v8);
      goto LABEL_23;
    default:
      sub_6940(
        (int)"_Unwind_VRS_Result _Unwind_VRS_Set(_Unwind_Context *, _Unwind_VRS_RegClass, uint32_t, _Unwind_VRS_DataRepre"
             "sentation, void *)",
        831,
        (int)"unsupported register class");
      return result;
  }
}

//----- (00006608) --------------------------------------------------------
signed int __fastcall sub_6608(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // r5@1
  int v5; // r7@1
  unsigned int v6; // r6@1
  int v7; // r8@1
  int v8; // r4@4
  unsigned int v9; // r7@4
  int *v10; // r0@6
  signed int v11; // r0@6
  signed int v12; // r1@6
  signed int v13; // r2@6
  signed int result; // r0@14
  unsigned int v15; // r4@18
  unsigned int v16; // r6@18
  int v17; // r0@19
  int v18; // r2@19
  int v19; // r0@19
  int v20; // r2@22
  int v21; // [sp+8h] [bp-38h]@19
  int v22; // [sp+Ch] [bp-34h]@19
  int v23; // [sp+14h] [bp-2Ch]@16
  int v24; // [sp+18h] [bp-28h]@6
  int *v25; // [sp+1Ch] [bp-24h]@3

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  switch ( a2 )
  {
    case 0:
    case 4:
      if ( a4 || sub_6A9C(a1, 13, &v25) )
        return 2;
      v8 = 0;
      v9 = 0;
      do
      {
        if ( (1 << v9) & v6 )
        {
          v10 = v25;
          ++v25;
          v24 = *v10;
          v11 = sub_6564(v7, v4, v9, 0, &v24);
          v12 = 0;
          v13 = 0;
          if ( v9 == 13 )
            v12 = 1;
          if ( !v4 )
            v13 = 1;
          if ( v11 )
            return 2;
          v8 |= v13 & v12;
        }
        ++v9;
      }
      while ( v9 < 0x10 );
      if ( v8 & 1 )
        return 0;
      v20 = (int)v25;
      goto LABEL_28;
    case 1:
    case 3:
      if ( (a4 | 4) != 5 || sub_6A9C(a1, 13, &v23) )
        return 2;
      if ( !(_WORD)v6 )
        goto LABEL_21;
      v15 = v6 >> 16;
      v16 = (v6 >> 16) + v6;
      break;
    default:
      sub_6940(
        (int)"_Unwind_VRS_Result _Unwind_VRS_Pop(_Unwind_Context *, _Unwind_VRS_RegClass, uint32_t, _Unwind_VRS_DataRepresentation)",
        965,
        (int)"unsupported register class");
      return result;
  }
  do
  {
    v17 = v23;
    v23 += 4;
    v18 = *(_DWORD *)v17;
    v23 = v17 + 8;
    v19 = *(_DWORD *)(v17 + 4);
    v21 = v18;
    v22 = v19;
    if ( sub_6564(v7, v4, v15, v5, &v21) )
      return 2;
    ++v15;
  }
  while ( v15 < v16 );
LABEL_21:
  if ( v5 == 1 )
  {
    v20 = v23 + 4;
    v23 += 4;
  }
  else
  {
    v20 = v23;
  }
LABEL_28:
  result = sub_6ACC(v7, 13, v20);
  if ( result )
    result = 2;
  return result;
}

//----- (0000672C) --------------------------------------------------------
signed int __fastcall sub_672C(int a1, int a2, int a3)
{
  int v3; // r0@1
  int v4; // r1@1
  unsigned int *v5; // r12@1
  int v6; // r3@1
  unsigned int v7; // r3@4
  unsigned int v8; // r2@4

  v3 = a2;
  v4 = a3;
  v5 = *(unsigned int **)(v3 + 76);
  v6 = (*v5 >> 24) & 0xF;
  if ( v6 )
  {
    if ( v6 != 1 && v6 != 3 )
      return 9;
    v7 = 4 * ((*v5 >> 16) & 0xFF) + 4;
    v8 = 2;
  }
  else
  {
    v8 = 1;
    v7 = 4;
  }
  if ( !v5 || !(*(_BYTE *)(v3 + 80) & 1) && *(unsigned int *)((char *)v5 + v7) )
    return 9;
  return sub_6220(v4, (int)v5, v8, v7);
}

//----- (00006780) --------------------------------------------------------
void sub_6780()
{
  JUMPOUT(&loc_6734);
}

//----- (00006788) --------------------------------------------------------
void sub_6788()
{
  JUMPOUT(&loc_6734);
}

//----- (00006824) --------------------------------------------------------
signed int __fastcall sub_6824(int a1, int a2, char a3)
{
  int v3; // r4@1
  char v4; // r10@1
  signed int i; // r6@1
  signed int v6; // r7@3
  int v7; // r0@8
  int (__fastcall *v8)(signed int, int, char *); // r3@11
  int v9; // r0@12
  int v11; // [sp+0h] [bp-4B0h]@17
  int v12; // [sp+4h] [bp-4ACh]@10
  int (__fastcall *v13)(signed int, int, char *); // [sp+10h] [bp-4A0h]@11
  int v14; // [sp+18h] [bp-498h]@12
  int v15; // [sp+24h] [bp-48Ch]@12
  int v16; // [sp+2Ch] [bp-484h]@10
  char v17; // [sp+30h] [bp-480h]@1

  v3 = a2;
  v4 = a3;
  sub_6A4C((int)&v17);
  for ( i = 1; ; --i )
  {
    v6 = 1;
    if ( v4 & 1 )
    {
      v6 = 2;
      if ( !i )
      {
        sub_6ACC((int)&v17, -1, *(_DWORD *)(v3 + 16));
        v4 = 0;
      }
    }
    v7 = sub_6B78((int)&v17);
    if ( !v7 )
      break;
    if ( v7 < 0 )
      return 2;
    sub_6A9C((int)&v17, -2, &v16);
    if ( sub_6B80((int)&v17, (int)&v12) )
      return 2;
    v8 = v13;
    if ( v13 )
    {
      *(_DWORD *)(v3 + 72) = v12;
      *(_DWORD *)(v3 + 76) = v15;
      *(_DWORD *)(v3 + 80) = v14;
      v9 = v8(v6, v3, &v17);
      if ( v9 == 7 )
      {
        sub_6A9C((int)&v17, -1, &v11);
        *(_DWORD *)(v3 + 16) = v11;
        sub_6BA0((int)&v17);
        return 2;
      }
      if ( v9 == 9 )
        abort();
      if ( v9 != 8 )
        return 2;
      if ( v16 == *(_DWORD *)(v3 + 32) )
        sub_6940(
          (int)"_Unwind_Reason_Code unwind_phase2(unw_context_t *, _Unwind_Exception *, bool)",
          642,
          (int)"during phase1 personality function said it would stop here, but now in phase2 it did not stop here");
    }
  }
  return 5;
}

//----- (00006940) --------------------------------------------------------
void __fastcall sub_6940(int a1, int a2, int a3)
{
  fprintf((FILE *)stderr, "libunwind: %s %s:%d - %s\n", a1, "external/libcxxabi/src/Unwind/Unwind-EHABI.cpp", a2, a3);
  abort();
}

//----- (000069C4) --------------------------------------------------------
int __fastcall sub_69C4(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4@0
  int v6; // r5@0
  int v7; // r6@0
  int v8; // r7@0
  int v9; // r8@0
  int v10; // r9@0
  int v11; // r10@0
  int v12; // r11@0
  int v13; // r12@0
  int v14; // lr@0

  *(_DWORD *)a1 = a1;
  *(_DWORD *)(a1 + 4) = a2;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v6;
  *(_DWORD *)(a1 + 24) = v7;
  *(_DWORD *)(a1 + 28) = v8;
  *(_DWORD *)(a1 + 32) = v9;
  *(_DWORD *)(a1 + 36) = v10;
  *(_DWORD *)(a1 + 40) = v11;
  *(_DWORD *)(a1 + 44) = v12;
  *(_DWORD *)(a1 + 48) = v13;
  *(_DWORD *)(a1 + 52) = &a5;
  *(_DWORD *)(a1 + 56) = v14;
  *(_DWORD *)(a1 + 60) = v14;
  return 0;
}

//----- (000069DC) --------------------------------------------------------
int __fastcall sub_69DC(int _R0)
{
  int result; // r0@1

  __asm { VSTMIA          R0, {D0-D15} }
  return result;
}

//----- (000069E4) --------------------------------------------------------
int __fastcall sub_69E4(int _R0)
{
  int result; // r0@1

  __asm { VSTMIA          R0, {D0-D15} }
  return result;
}

//----- (000069EC) --------------------------------------------------------
int __fastcall sub_69EC(int _R0)
{
  int result; // r0@1

  __asm { VSTMIA          R0, {D16-D31} }
  return result;
}

//----- (000069F4) --------------------------------------------------------
void sub_69F4()
{
  __asm
  {
    STCL            p1, c0, [R0],#8
    STCL            p1, c1, [R0],#8
    STCL            p1, c2, [R0],#8
    STCL            p1, c3, [R0],#8
    STCL            p1, c4, [R0],#8
    STCL            p1, c5, [R0],#8
    STCL            p1, c6, [R0],#8
    STCL            p1, c7, [R0],#8
    STCL            p1, c8, [R0],#8
    STCL            p1, c9, [R0],#8
    STCL            p1, c10, [R0],#8
    STCL            p1, c11, [R0],#8
    STCL            p1, c12, [R0],#8
    STCL            p1, c13, [R0],#8
    STCL            p1, c14, [R0],#8
    STCL            p1, c15, [R0],#8
  }
}

//----- (00006A38) --------------------------------------------------------
void sub_6A38()
{
  __asm
  {
    STC2            p1, c8, [R0],#4
    STC2            p1, c9, [R0],#4
    STC2            p1, c10, [R0],#4
    STC2            p1, c11, [R0],#4
  }
}

//----- (00006A4C) --------------------------------------------------------
int __fastcall sub_6A4C(int a1)
{
  int v1; // r4@1

  v1 = a1;
  *(_DWORD *)a1 = &off_ACB0;
  *(_DWORD *)(a1 + 4) = &unk_B090;
  *(_BYTE *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  _aeabi_memcpy(a1 + 8);
  _aeabi_memset(v1 + 80, 450, 0);
  sub_6FD0(v1, 0);
  return 0;
}
// 2AD4: using guessed type int __fastcall _aeabi_memcpy(_DWORD);
// 2AE0: using guessed type int __fastcall _aeabi_memset(_DWORD, _DWORD, _DWORD);
// ACB0: using guessed type void *;

//----- (00006A9C) --------------------------------------------------------
signed int __fastcall sub_6A9C(int a1, int a2, _DWORD *a3)
{
  int v3; // r6@1
  _DWORD *v4; // r4@1
  int v5; // r5@1
  signed int result; // r0@2

  v3 = a1;
  v4 = a3;
  v5 = a2;
  if ( (*(int (**)(void))(*(_DWORD *)a1 + 8))() == 1 )
  {
    *v4 = (*(int (__fastcall **)(int, int))(*(_DWORD *)v3 + 12))(v3, v5);
    result = 0;
  }
  else
  {
    result = -6542;
  }
  return result;
}

//----- (00006ACC) --------------------------------------------------------
signed int __fastcall sub_6ACC(int a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r6@1
  int v5; // r5@1
  signed int v6; // r5@3

  v3 = a1;
  v4 = a3;
  v5 = a2;
  if ( (*(int (**)(void))(*(_DWORD *)a1 + 8))() == 1 )
  {
    (*(void (__fastcall **)(int, int, int))(*(_DWORD *)v3 + 16))(v3, v5, v4);
    if ( v5 == -1 )
    {
      v6 = 0;
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)v3 + 52))(v3, 0);
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v6 = -6542;
  }
  return v6;
}

//----- (00006B10) --------------------------------------------------------
signed int __fastcall sub_6B10(int a1, int a2, _QWORD *a3)
{
  int v3; // r6@1
  _QWORD *v4; // r4@1
  int v5; // r5@1
  __int64 v6; // r0@2
  signed int result; // r0@2

  v3 = a1;
  v4 = a3;
  v5 = a2;
  if ( (*(int (**)(void))(*(_DWORD *)a1 + 20))() == 1 )
  {
    LODWORD(v6) = (*(int (__fastcall **)(int, int))(*(_DWORD *)v3 + 24))(v3, v5);
    *v4 = v6;
    result = 0;
  }
  else
  {
    result = -6542;
  }
  return result;
}

//----- (00006B40) --------------------------------------------------------
signed int __fastcall sub_6B40(int a1, int a2, int a3, int a4)
{
  int v4; // r7@1
  int v5; // r5@1
  int v6; // r6@1
  int v7; // r8@1
  signed int result; // r0@2

  v4 = a1;
  v5 = a3;
  v6 = a2;
  v7 = a4;
  if ( (*(int (**)(void))(*(_DWORD *)a1 + 20))() == 1 )
  {
    (*(void (__fastcall **)(int, int, int, int))(*(_DWORD *)v4 + 28))(v4, v6, v5, v7);
    result = 0;
  }
  else
  {
    result = -6542;
  }
  return result;
}

//----- (00006B78) --------------------------------------------------------
int __fastcall sub_6B78(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 32))();
}

//----- (00006B80) --------------------------------------------------------
signed int __fastcall sub_6B80(int a1, int a2)
{
  int v2; // r4@1
  signed int result; // r0@1

  v2 = a2;
  (*(void (**)(void))(*(_DWORD *)a1 + 36))();
  result = 0;
  if ( !*(_DWORD *)(v2 + 4) )
    result = -6549;
  return result;
}

//----- (00006BA0) --------------------------------------------------------
signed int __fastcall sub_6BA0(int a1)
{
  (*(void (**)(void))(*(_DWORD *)a1 + 40))();
  return -6540;
}

//----- (00006BB8) --------------------------------------------------------
int __fastcall sub_6BB8(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 60))();
}

//----- (00006BC8) --------------------------------------------------------
int __fastcall sub_6BC8(int a1, int a2)
{
  signed int v2; // r2@1
  bool v3; // zf@1
  signed int v4; // r0@1
  unsigned int v5; // r1@1

  v2 = 0;
  v3 = (a2 & 0xFFFFFFFC) == 192;
  v4 = 0;
  v5 = a2 - 16;
  if ( v3 )
    v4 = 1;
  if ( v5 > 0xFFFFFFED )
    v2 = 1;
  return v4 | v2;
}

//----- (00006BEC) --------------------------------------------------------
int __fastcall sub_6BEC(int a1, signed int a2)
{
  signed int v2; // r5@1
  int v3; // r4@1
  int v4; // r0@7

  v2 = a2;
  v3 = a1;
  if ( a2 >= -1 )
  {
    if ( a2 > 13 )
    {
      if ( a2 == 14 )
      {
        v4 = a1 + 64;
        return *(_DWORD *)v4;
      }
      if ( a2 != 15 )
        goto LABEL_12;
    }
    else if ( a2 != -1 )
    {
      if ( a2 != 13 )
        goto LABEL_12;
LABEL_7:
      v4 = a1 + 60;
      return *(_DWORD *)v4;
    }
    v4 = a1 + 68;
    return *(_DWORD *)v4;
  }
  if ( a2 == -2 )
    goto LABEL_7;
LABEL_12:
  if ( (unsigned int)a2 > 0xC )
  {
    if ( (a2 & 0xFFFFFFFC) != 192 )
      sub_702C(
        (int)"uint32_t libunwind::Registers_arm::getRegister(int)",
        (int)"external/libcxxabi/src/Unwind/Registers.hpp",
        1452,
        (int)"unsupported arm register");
    if ( !*(_BYTE *)(a1 + 76) )
    {
      *(_BYTE *)(a1 + 76) = 1;
      sub_6A38();
    }
    v4 = v3 + 4 * v2 - 296;
  }
  else
  {
    v4 = a1 + 4 * a2 + 8;
  }
  return *(_DWORD *)v4;
}

//----- (00006C88) --------------------------------------------------------
int __fastcall sub_6C88(int result, signed int a2, int a3)
{
  signed int v3; // r6@1
  int v4; // r4@1
  int v5; // r5@1

  v3 = a2;
  v4 = a3;
  v5 = result;
  if ( a2 >= -1 )
  {
    if ( a2 > 13 )
    {
      if ( a2 == 14 )
      {
        *(_DWORD *)(result + 64) = a3;
        return result;
      }
      if ( a2 != 15 )
        goto LABEL_12;
    }
    else if ( a2 != -1 )
    {
      if ( a2 != 13 )
        goto LABEL_12;
LABEL_7:
      *(_DWORD *)(result + 60) = a3;
      return result;
    }
    *(_DWORD *)(result + 68) = a3;
    return result;
  }
  if ( a2 == -2 )
    goto LABEL_7;
LABEL_12:
  if ( (unsigned int)a2 > 0xC )
  {
    if ( (a2 & 0xFFFFFFFC) != 192 )
      sub_702C(
        (int)"void libunwind::Registers_arm::setRegister(int, uint32_t)",
        (int)"external/libcxxabi/src/Unwind/Registers.hpp",
        1471,
        (int)"unsupported arm register");
    if ( !*(_BYTE *)(result + 76) )
    {
      *(_BYTE *)(result + 76) = 1;
      sub_6A38();
    }
    result = v5 + 4 * v3;
    *(_DWORD *)(result - 296) = v4;
  }
  else
  {
    result += 4 * a2;
    *(_DWORD *)(result + 8) = a3;
  }
  return result;
}

//----- (00006D20) --------------------------------------------------------
int __fastcall sub_6D20(int a1, int a2)
{
  signed int v2; // r2@1
  bool v3; // zf@1
  signed int v4; // r0@1
  unsigned int v5; // r1@1

  v2 = 0;
  v3 = (a2 & 0xFFFFFFF0) == 112;
  v4 = 0;
  v5 = a2 & 0xFFFFFFE0;
  if ( v3 )
    v4 = 1;
  if ( v5 == 256 )
    v2 = 1;
  return v4 | v2;
}

//----- (00006D44) --------------------------------------------------------
__int64 __fastcall sub_6D44(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r5@1
  unsigned int v4; // r0@1
  int v5; // r0@5
  int v6; // r0@11

  v2 = a2;
  v3 = a1;
  v4 = a2 & 0xFFFFFFF0;
  if ( (a2 & 0xFFFFFFF0) == 112 )
  {
    if ( !*(_BYTE *)(v3 + 75) )
    {
      *(_BYTE *)(v3 + 75) = 1;
      sub_69F4();
    }
    v5 = v3 + 8 * v2 - 552;
  }
  else if ( v4 == 272 )
  {
    if ( !*(_BYTE *)(v3 + 74) )
    {
      *(_BYTE *)(v3 + 74) = 1;
      sub_69EC(v3 + 216);
    }
    v5 = v3 + 8 * v2 - 1960;
  }
  else
  {
    if ( v4 != 256 )
      sub_702C(
        (int)"unw_fpreg_t libunwind::Registers_arm::getFloatRegister(int)",
        (int)"external/libcxxabi/src/Unwind/Registers.hpp",
        1673,
        (int)"Unknown ARM float register");
    if ( !*(_BYTE *)(v3 + 73) )
    {
      *(_BYTE *)(v3 + 73) = 1;
      v6 = v3 + 80;
      if ( *(_BYTE *)(v3 + 72) )
        sub_69E4(v6);
      else
        sub_69DC(v6);
    }
    v5 = v3 + 8 * v2 - 1968;
  }
  return *(_QWORD *)v5;
}

//----- (00006DF4) --------------------------------------------------------
int __fastcall sub_6DF4(int a1, int a2, int a3, int a4)
{
  int v4; // r6@1
  int v5; // r7@1
  unsigned int v6; // r0@1
  int v7; // r5@1
  int v8; // r4@1
  int result; // r0@5
  int v10; // r1@5
  int v11; // r0@11

  v4 = a2;
  v5 = a1;
  v6 = a2 & 0xFFFFFFF0;
  v7 = a4;
  v8 = a3;
  if ( (a2 & 0xFFFFFFF0) == 112 )
  {
    if ( !*(_BYTE *)(v5 + 75) )
    {
      *(_BYTE *)(v5 + 75) = 1;
      sub_69F4();
    }
    result = v5 + 8 * v4;
    *(_DWORD *)(result - 548) = v7;
    LOWORD(v10) = -552;
  }
  else if ( v6 == 272 )
  {
    if ( !*(_BYTE *)(v5 + 74) )
    {
      *(_BYTE *)(v5 + 74) = 1;
      sub_69EC(v5 + 216);
    }
    result = v5 + 8 * v4;
    *(_DWORD *)(result - 1828) = v7;
    LOWORD(v10) = -1832;
  }
  else
  {
    if ( v6 != 256 )
      sub_702C(
        (int)"void libunwind::Registers_arm::setFloatRegister(int, unw_fpreg_t)",
        (int)"external/libcxxabi/src/Unwind/Registers.hpp",
        1700,
        (int)"Unknown ARM float register");
    if ( !*(_BYTE *)(v5 + 73) )
    {
      *(_BYTE *)(v5 + 73) = 1;
      v11 = v5 + 80;
      if ( *(_BYTE *)(v5 + 72) )
        sub_69E4(v11);
      else
        sub_69DC(v11);
    }
    result = v5 + 8 * v4;
    *(_DWORD *)(result - 1964) = v7;
    LOWORD(v10) = -1968;
  }
  HIWORD(v10) = -1;
  *(_DWORD *)(result + v10) = v8;
  return result;
}

//----- (00006EC8) --------------------------------------------------------
signed int __fastcall sub_6EC8(int a1)
{
  int v1; // r4@1
  signed int result; // r0@3
  void (__fastcall *v3)(int, signed int, int); // r5@5
  int v4; // r0@5

  v1 = a1;
  if ( *(_BYTE *)(a1 + 528)
    || ((*(void (__fastcall **)(int, signed int))(*(_DWORD *)a1 + 52))(a1, 1), *(_BYTE *)(v1 + 528)) )
  {
    result = 0;
  }
  else
  {
    if ( *(_DWORD *)(v1 + 504) )
    {
      v3 = *(void (__fastcall **)(int, signed int, int))(*(_DWORD *)v1 + 16);
      v4 = (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v1 + 12))(v1, -2);
      v3(v1, -2, *(_DWORD *)(v1 + 504) + v4);
    }
    result = 1;
  }
  return result;
}

//----- (00006F14) --------------------------------------------------------
int __fastcall sub_6F14(int a1, int a2)
{
  int v2; // r3@1
  int v3; // r4@1
  int v4; // r5@1
  int v5; // r12@1
  int v6; // lr@1
  int v7; // r4@1
  int v8; // r2@1
  int v9; // r3@1
  int v10; // r5@1
  int result; // r0@1

  v2 = *(_DWORD *)(a1 + 504);
  v3 = *(_DWORD *)(a1 + 496);
  v4 = *(_DWORD *)(a1 + 500);
  v5 = *(_DWORD *)(a1 + 488);
  v6 = *(_DWORD *)(a1 + 492);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 508);
  *(_DWORD *)(a2 + 16) = v2;
  *(_DWORD *)(a2 + 12) = v4;
  *(_DWORD *)(a2 + 8) = v3;
  v7 = a2 + 24;
  *(_DWORD *)a2 = v5;
  *(_DWORD *)(a2 + 4) = v6;
  v8 = *(_DWORD *)(a1 + 512);
  v9 = *(_DWORD *)(a1 + 516);
  v10 = *(_DWORD *)(a1 + 520);
  result = *(_DWORD *)(a1 + 524);
  *(_DWORD *)(a2 + 36) = result;
  *(_DWORD *)v7 = v8;
  *(_DWORD *)(v7 + 4) = v9;
  *(_DWORD *)(v7 + 8) = v10;
  return result;
}

//----- (00006F54) --------------------------------------------------------
void __fastcall sub_6F54(int a1)
{
  sub_7060(a1 + 8);
  sub_7DB0();
}

//----- (00006F6C) --------------------------------------------------------
int __fastcall sub_6F6C(int a1)
{
  return *(_BYTE *)(a1 + 529);
}

//----- (00006F74) --------------------------------------------------------
signed int __fastcall sub_6F74(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // r6@1
  int v5; // r5@1
  _DWORD *v6; // r4@1
  int v7; // r7@1
  signed int result; // r0@3
  int v9; // [sp+10h] [bp-20h]@2
  int v10; // [sp+14h] [bp-1Ch]@3

  v4 = a2;
  v5 = a3;
  v6 = a4;
  v7 = (*(int (**)(void))(*(_DWORD *)a1 + 12))();
  if ( dladdr() && v9 )
  {
    _snprintf_chk(v4, v5, 0, -1);
    *v6 = v7 - v10;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 2AEC: using guessed type int dladdr(void);
// 2AF8: using guessed type int __fastcall _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00006FD0) --------------------------------------------------------
int __fastcall sub_6FD0(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r6@1
  unsigned int v4; // r5@1
  int result; // r0@5
  int v6; // [sp+4h] [bp-1Ch]@3
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@1

  v2 = a1;
  v3 = a2;
  v4 = (*(int (**)(void))(*(_DWORD *)a1 + 12))() & 0xFFFFFFFE;
  v8 = 0;
  if ( v3 )
    --v4;
  v6 = _gnu_Unwind_Find_exidx(v4, &v8);
  v7 = v8;
  if ( !v6 || !v8 || (result = ((int (__fastcall *)(int, unsigned int, int *))sub_70B0)(v2, v4, &v6)) == 0 )
  {
    result = 1;
    *(_BYTE *)(v2 + 528) = 1;
  }
  return result;
}
// 2B04: using guessed type int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD);
// 70B0: using guessed type int sub_70B0();

//----- (0000701C) --------------------------------------------------------
const char *__fastcall sub_701C(int a1, signed int a2)
{
  const char *result; // r0@2
  signed int v3; // r0@3
  int *v4; // r1@3

  if ( a2 > 255 )
  {
    switch ( a2 )
    {
      case 256:
        v3 = -7803;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 257:
        v3 = -7800;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 258:
        v3 = -7797;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 259:
        v3 = -7794;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 260:
        v3 = -7791;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 261:
        v3 = -7788;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 262:
        v3 = -7785;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 263:
        v3 = -7782;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 264:
        v3 = -7779;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 265:
        v3 = -7776;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 266:
        v3 = -7773;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 267:
        v3 = -7769;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 268:
        v3 = -7765;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 269:
        v3 = -7761;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 270:
        v3 = -7757;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 271:
        v3 = -7753;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 272:
        v3 = -7749;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 273:
        v3 = -7745;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 274:
        v3 = -7741;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 275:
        v3 = -7737;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 276:
        v3 = -7733;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 277:
        v3 = -7729;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 278:
        v3 = -7725;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 279:
        v3 = -7721;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 280:
        v3 = -7717;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 281:
        v3 = -7713;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 282:
        v3 = -7709;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 283:
        v3 = -7705;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 284:
        v3 = -7701;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 285:
        v3 = -7697;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 286:
        v3 = -7693;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 287:
        v3 = -7689;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      default:
def_738C:
        v3 = -7685;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
    }
  }
  else
  {
    result = "pc";
    switch ( a2 + 2 )
    {
      case 0:
      case 15:
        v3 = -7966;
        v4 = &GLOBAL_OFFSET_TABLE_;
        return (char *)v4 + v3;
      default:
        goto def_738C;
      case 1:
      case 17:
        return result;
      case 2:
        v3 = -7963;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 3:
        v3 = -7960;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 4:
        v3 = -7957;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 5:
        v3 = -7954;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 6:
        v3 = -7951;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 7:
        v3 = -7948;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 8:
        v3 = -7945;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 9:
        v3 = -7942;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 10:
        v3 = -7939;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 11:
        v3 = -7936;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 12:
        v3 = -7933;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 13:
        v3 = -7929;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 14:
        v3 = -7925;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 16:
        v3 = -7969;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 66:
        v3 = -7921;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 67:
        v3 = -7918;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 68:
        v3 = -7915;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 69:
        v3 = -7912;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 70:
        v3 = -7909;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 71:
        v3 = -7906;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 72:
        v3 = -7903;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 73:
        v3 = -7900;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 74:
        v3 = -7897;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 75:
        v3 = -7894;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 76:
        v3 = -7891;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 77:
        v3 = -7887;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 78:
        v3 = -7883;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 79:
        v3 = -7879;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 80:
        v3 = -7875;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 81:
        v3 = -7871;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 82:
        v3 = -7867;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 83:
        v3 = -7863;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 84:
        v3 = -7859;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 85:
        v3 = -7855;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 86:
        v3 = -7851;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 87:
        v3 = -7847;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 88:
        v3 = -7843;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 89:
        v3 = -7839;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 90:
        v3 = -7835;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 91:
        v3 = -7831;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 92:
        v3 = -7827;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 93:
        v3 = -7823;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 94:
        v3 = -7819;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 95:
        v3 = -7815;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 96:
        v3 = -7811;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
      case 97:
        v3 = -7807;
        v4 = &GLOBAL_OFFSET_TABLE_;
        break;
    }
  }
  return (char *)v4 + v3;
}
// AE1C: using guessed type int GLOBAL_OFFSET_TABLE_;

//----- (00007024) --------------------------------------------------------
int __fastcall sub_7024(int result)
{
  *(_BYTE *)(result + 72) = 1;
  return result;
}

//----- (0000702C) --------------------------------------------------------
void __fastcall sub_702C(int a1, int a2, int a3, int a4)
{
  fprintf((FILE *)stderr, "libunwind: %s %s:%d - %s\n", a1, a2, a3, a4);
  abort();
}

//----- (00007060) --------------------------------------------------------
int __fastcall sub_7060(int a1)
{
  int v1; // r4@1
  int v2; // r0@2
  int result; // r0@9

  v1 = a1;
  if ( *(_BYTE *)(a1 + 65) )
  {
    v2 = a1 + 72;
    if ( *(_BYTE *)(v1 + 64) )
      sub_7934(v2);
    else
      sub_792C(v2);
  }
  if ( *(_BYTE *)(v1 + 66) )
    sub_793C(v1 + 208);
  if ( *(_BYTE *)(v1 + 67) )
    sub_7944((_DWORD *)(v1 + 336));
  result = *(_BYTE *)(v1 + 68);
  if ( *(_BYTE *)(v1 + 68) )
    result = sub_7DC0((_DWORD *)(v1 + 464));
  return result;
}

//----- (00007240) --------------------------------------------------------
int __fastcall sub_7240(int result, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, _DWORD *a8)
{
  unsigned int v8; // r4@1
  unsigned int v9; // r5@2
  int v10; // r6@3

  v8 = a5 - a2;
  while ( 1 )
  {
    v9 = v8;
    if ( !v8 )
      break;
    v10 = a2 + (v8 >> 1);
    v8 >>= 1;
    if ( *a8 >= *a4 + 8 * v10 + (2 * *(_DWORD *)(*a4 + 8 * v10) & 0x80000000 | *(_DWORD *)(*a4 + 8 * v10)) )
    {
      v8 = v9 - 1 - v8;
      a2 = v10 + 1;
    }
  }
  *(_DWORD *)result = a2;
  *(_DWORD *)(result + 4) = a3;
  *(_DWORD *)(result + 8) = a4;
  return result;
}

//----- (0000792C) --------------------------------------------------------
int __fastcall sub_792C(int _R0)
{
  int result; // r0@1

  __asm { VLDMIA          R0, {D0-D15} }
  return result;
}

//----- (00007934) --------------------------------------------------------
int __fastcall sub_7934(int _R0)
{
  int result; // r0@1

  __asm { VLDMIA          R0, {D0-D15} }
  return result;
}

//----- (0000793C) --------------------------------------------------------
int __fastcall sub_793C(int _R0)
{
  int result; // r0@1

  __asm { VLDMIA          R0, {D16-D31} }
  return result;
}

//----- (00007944) --------------------------------------------------------
int __fastcall sub_7944(_DWORD *a1)
{
  int *v5; // r0@1
  int result; // r0@1

  _T1 = *a1;
  v5 = a1 + 2;
  __asm { LDCL            p1, c0, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c1, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c2, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c3, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c4, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c5, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c6, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c7, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c8, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c9, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c10, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c11, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c12, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c13, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c14, [R0],#8 }
  _T1 = *v5;
  result = (int)(v5 + 2);
  __asm { LDCL            p1, c15, [R0],#8 }
  return result;
}

//----- (00007988) --------------------------------------------------------
int __fastcall sub_7988(_DWORD *a1)
{
  int *v5; // r0@1
  int result; // r0@1

  _T1 = *a1;
  v5 = a1 + 1;
  __asm { LDC2            p1, c8, [R0],#4 }
  _T1 = *v5;
  ++v5;
  __asm { LDC2            p1, c9, [R0],#4 }
  _T1 = *v5;
  ++v5;
  __asm { LDC2            p1, c10, [R0],#4 }
  _T1 = *v5;
  result = (int)(v5 + 1);
  __asm { LDC2            p1, c11, [R0],#4 }
  return result;
}

//----- (00007A1C) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (00007A2C) --------------------------------------------------------
signed __int64 __fastcall _gnu_ldivmod_helper(signed __int64 a1, signed __int64 a2, _QWORD *a3)
{
  signed __int64 v3; // r4@1
  signed __int64 result; // r0@1

  v3 = a1;
  result = a1 / a2;
  *a3 = v3 - result * a2;
  return result;
}

//----- (00007A68) --------------------------------------------------------
unsigned __int64 __fastcall _gnu_uldivmod_helper(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  unsigned __int64 v3; // r6@1
  unsigned __int64 result; // r0@1

  v3 = a1;
  result = a1 / a2;
  *a3 = v3 - result * a2;
  return result;
}

//----- (00007D48) --------------------------------------------------------
unsigned int __fastcall _lshrdi3(unsigned int a1, unsigned int a2, int a3)
{
  unsigned int result; // r0@2

  if ( a3 - 32 >= 0 )
    result = a2 >> (a3 - 32);
  else
    result = a1 >> a3;
  if ( a3 - 32 < 0 )
    result |= a2 << (32 - a3);
  return result;
}

//----- (00007D80) --------------------------------------------------------
int __fastcall j_j_j___android_log_buf_write(signed int a1, int a2, const char *a3, const char *a4)
{
  return j_j___android_log_buf_write(a1, a2, a3, a4);
}

//----- (00007D84) --------------------------------------------------------
int __fastcall j_j___android_log_buf_write(signed int a1, int a2, const char *a3, const char *a4)
{
  return j___android_log_buf_write(a1, a2, a3, a4);
}

//----- (00007D90) --------------------------------------------------------
void j_j_free(void *ptr)
{
  j_free(ptr);
}

//----- (00007D94) --------------------------------------------------------
void j_free(void *ptr)
{
  free(ptr);
}

//----- (00007DA0) --------------------------------------------------------
int j_j_ioctl(int fd, unsigned __int32 request, ...)
{
  return j_ioctl(fd, request);
}

//----- (00007DA4) --------------------------------------------------------
int j_ioctl(int fd, unsigned __int32 request, ...)
{
  return ioctl(fd, request);
}

//----- (00007DB0) --------------------------------------------------------
void sub_7DB0()
{
  sub_7DB4();
}

//----- (00007DB4) --------------------------------------------------------
void sub_7DB4()
{
  JUMPOUT(sub_7918);
}
// 7918: using guessed type int sub_7918();

//----- (00007DC0) --------------------------------------------------------
int __fastcall sub_7DC0(_DWORD *a1)
{
  return sub_7DC4(a1);
}

//----- (00007DC4) --------------------------------------------------------
int __fastcall sub_7DC4(_DWORD *a1)
{
  return sub_7988(a1);
}

// ALL OK, 171 function(s) have been successfully decompiled
